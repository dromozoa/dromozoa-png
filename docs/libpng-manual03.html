<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>III. Reading</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
<style>
.markdown-body {
  box-sizing: border-box;
  min-width: 200px;
  max-width: 980px;
  margin: 0 auto;
  padding: 45px;
}
@media (max-width: 767px) {
  .markdown-body {
    padding: 15px;
  }
}
</style>
</head>
<body>
<div class="markdown-body">

<h1>III. Reading</h1>

<pre>III. Reading

We'll now walk you through the possible functions to call when reading
in a PNG file sequentially, briefly explaining the syntax and purpose
of each one.  See example.c and png.h for more detail.  While
progressive reading is covered in the next section, you will still
need some of the functions discussed in this section to read a PNG
file.

Setup

You will want to do the I/O initialization(*) before you get into libpng,
so if it doesn't work, you don't have much to undo.  Of course, you
will also want to insure that you are, in fact, dealing with a PNG
file.  Libpng provides a simple check to see if a file is a PNG file.
To use it, pass in the first 1 to 8 bytes of the file to the function
<a href="png.h.html#L944">png_sig_cmp</a>(), and it will return 0 (false) if the bytes match the
corresponding bytes of the PNG signature, or nonzero (true) otherwise.
Of course, the more bytes you pass in, the greater the accuracy of the
prediction.

If you are intending to keep the file pointer open for use in libpng,
you must ensure you don't read more than 8 bytes from the beginning
of the file, and you also have to make a call to <a href="png.h.html#L937">png_set_sig_bytes</a>()
with the number of bytes you read from the beginning.  Libpng will
then only check the bytes (if any) that your program didn't read.

(*): If you are not using the standard I/O functions, you will need
to replace them with custom functions.  See the discussion under
Customizing libpng.

    FILE *fp = fopen(file_name, "rb");
    if (!fp)
    {
       return (ERROR);
    }

    if (fread(header, 1, number, fp) != number)
    {
       return (ERROR);
    }

    is_png = !<a href="png.h.html#L944">png_sig_cmp</a>(header, 0, number);
    if (!is_png)
    {
       return (NOT_PNG);
    }

Next, png_struct and png_info need to be allocated and initialized.  In
order to ensure that the size of these structures is correct even with a
dynamically linked libpng, there are functions to initialize and
allocate the structures.  We also pass the library version, optional
pointers to error handling functions, and a pointer to a data struct for
use by the error functions, if necessary (the pointer and functions can
be NULL if the default error handlers are to be used).  See the section
on Changes to Libpng below regarding the old initialization functions.
The structure allocation functions quietly return NULL if they fail to
create the structure, so your application should check for that.

    png_structp png_ptr = png_create_read_struct
        (<a href="png.h.html#L312">PNG_LIBPNG_VER_STRING</a>, (png_voidp)user_error_ptr,
        user_error_fn, user_warning_fn);

    if (!png_ptr)
       return (ERROR);

    png_infop info_ptr = png_create_info_struct(png_ptr);

    if (!info_ptr)
    {
       <a href="png.h.html#L1447">png_destroy_read_struct</a>(&amp;png_ptr,
           (png_infopp)NULL, (png_infopp)NULL);
       return (ERROR);
    }

If you want to use your own memory allocation routines,
use a libpng that was built with PNG_USER_MEM_SUPPORTED defined, and use
png_create_read_struct_2() instead of png_create_read_struct():

    png_structp png_ptr = png_create_read_struct_2
        (<a href="png.h.html#L312">PNG_LIBPNG_VER_STRING</a>, (png_voidp)user_error_ptr,
        user_error_fn, user_warning_fn, (png_voidp)
        user_mem_ptr, user_malloc_fn, user_free_fn);

The error handling routines passed to png_create_read_struct()
and the memory alloc/free routines passed to png_create_struct_2()
are only necessary if you are not using the libpng supplied error
handling and memory alloc/free functions.

When libpng encounters an error, it expects to longjmp back
to your routine.  Therefore, you will need to call setjmp and pass
your png_jmpbuf(png_ptr).  If you read the file from different
routines, you will need to update the longjmp buffer every time you enter
a new routine that will call a png_*() function.

See your documentation of setjmp/longjmp for your compiler for more
information on setjmp/longjmp.  See the discussion on libpng error
handling in the Customizing Libpng section below for more information
on the libpng error handling.  If an error occurs, and libpng longjmp's
back to your setjmp, you will want to call <a href="png.h.html#L1447">png_destroy_read_struct</a>() to
free any memory.

    if (setjmp(png_jmpbuf(png_ptr)))
    {
       <a href="png.h.html#L1447">png_destroy_read_struct</a>(&amp;png_ptr, &amp;info_ptr,
           &amp;end_info);
       fclose(fp);
       return (ERROR);
    }

Pass (png_infopp)NULL instead of &amp;end_info if you didn't create
an end_info structure.

If you would rather avoid the complexity of setjmp/longjmp issues,
you can compile libpng with PNG_NO_SETJMP, in which case
errors will result in a call to PNG_ABORT() which defaults to abort().

You can #define PNG_ABORT() to a function that does something
more useful than abort(), as long as your function does not
return.

Now you need to set up the input code.  The default for libpng is to
use the C function fread().  If you use this, you will need to pass a
valid FILE * in the function <a href="png.h.html#L1591">png_init_io</a>().  Be sure that the file is
opened in binary mode.  If you wish to handle reading data in another
way, you need not call the <a href="png.h.html#L1591">png_init_io</a>() function, but you must then
implement the libpng I/O methods discussed in the Customizing Libpng
section below.

    <a href="png.h.html#L1591">png_init_io</a>(png_ptr, fp);

If you had previously opened the file and read any of the signature from
the beginning in order to see if this was a PNG file, you need to let
libpng know that there are some bytes missing from the start of the file.

    <a href="png.h.html#L937">png_set_sig_bytes</a>(png_ptr, number);

You can change the zlib compression buffer size to be used while
reading compressed data with

    <a href="png.h.html#L967">png_set_compression_buffer_size</a>(png_ptr, buffer_size);

where the default size is 8192 bytes.  Note that the buffer size
is changed immediately and the buffer is reallocated immediately,
instead of setting a flag to be acted upon later.

If you want CRC errors to be handled in a different manner than
the default, use

    <a href="png.h.html#L1455">png_set_crc_action</a>(png_ptr, crit_action, ancil_action);

The values for <a href="png.h.html#L1455">png_set_crc_action</a>() say how libpng is to handle CRC errors in
ancillary and critical chunks, and whether to use the data contained
therein. Starting with libpng-1.6.26, this also governs how an ADLER32 error
is handled while reading the IDAT chunk. Note that it is impossible to
"discard" data in a critical chunk.

Choices for (int) crit_action are
   <a href="png.h.html#L1467">PNG_CRC_DEFAULT</a>      0  error/quit
   <a href="png.h.html#L1468">PNG_CRC_ERROR_QUIT</a>   1  error/quit
   <a href="png.h.html#L1470">PNG_CRC_WARN_USE</a>     3  warn/use data
   <a href="png.h.html#L1471">PNG_CRC_QUIET_USE</a>    4  quiet/use data
   <a href="png.h.html#L1472">PNG_CRC_NO_CHANGE</a>    5  use the current value

Choices for (int) ancil_action are
   <a href="png.h.html#L1467">PNG_CRC_DEFAULT</a>      0  error/quit
   <a href="png.h.html#L1468">PNG_CRC_ERROR_QUIT</a>   1  error/quit
   <a href="png.h.html#L1469">PNG_CRC_WARN_DISCARD</a> 2  warn/discard data
   <a href="png.h.html#L1470">PNG_CRC_WARN_USE</a>     3  warn/use data
   <a href="png.h.html#L1471">PNG_CRC_QUIET_USE</a>    4  quiet/use data
   <a href="png.h.html#L1472">PNG_CRC_NO_CHANGE</a>    5  use the current value

When the setting for crit_action is <a href="png.h.html#L1471">PNG_CRC_QUIET_USE</a>, the CRC and ADLER32
checksums are not only ignored, but they are not evaluated.

Setting up callback code

You can set up a callback function to handle any unknown chunks in the
input stream. You must supply the function

    read_chunk_callback(png_structp png_ptr,
         png_unknown_chunkp chunk);
    {
       /* The unknown chunk structure contains your
          chunk data, along with similar data for any other
          unknown chunks: */

           png_byte name[5];
           png_byte *data;
           png_size_t size;

       /* Note that libpng has already taken care of
          the CRC handling */

       /* put your code here.  Search for your chunk in the
          unknown chunk structure, process it, and return one
          of the following: */

       return (-n); /* chunk had an error */
       return (0); /* did not recognize */
       return (n); /* success */
    }

(You can give your function another name that you like instead of
"read_chunk_callback")

To inform libpng about your function, use

    <a href="png.h.html#L1697">png_set_read_user_chunk_fn</a>(png_ptr, user_chunk_ptr,
        read_chunk_callback);

This names not only the callback function, but also a user pointer that
you can retrieve with

    <a href="png.h.html#L1702">png_get_user_chunk_ptr</a>(png_ptr);

If you call the <a href="png.h.html#L1697">png_set_read_user_chunk_fn</a>() function, then all unknown
chunks which the callback does not handle will be saved when read.  You can
cause them to be discarded by returning '1' ("handled") instead of '0'.  This
behavior will change in libpng 1.7 and the default handling set by the
<a href="png.h.html#L2310">png_set_keep_unknown_chunks</a>() function, described below, will be used when the
callback returns 0.  If you want the existing behavior you should set the global
default to <a href="png.h.html#L2378">PNG_HANDLE_CHUNK_IF_SAFE</a> now; this is compatible with all current
versions of libpng and with 1.7.  Libpng 1.6 issues a warning if you keep the
default, or <a href="png.h.html#L2377">PNG_HANDLE_CHUNK_NEVER</a>, and the callback returns 0.

At this point, you can set up a callback function that will be
called after each row has been read, which you can use to control
a progress meter or the like.  It's demonstrated in pngtest.c.
You must supply a function

    void read_row_callback(png_structp png_ptr,
       png_uint_32 row, int pass);
    {
      /* put your code here */
    }

(You can give it another name that you like instead of "read_row_callback")

To inform libpng about your function, use

    <a href="png.h.html#L1628">png_set_read_status_fn</a>(png_ptr, read_row_callback);

When this function is called the row has already been completely processed and
the 'row' and 'pass' refer to the next row to be handled.  For the
non-interlaced case the row that was just handled is simply one less than the
passed in row number, and pass will always be 0.  For the interlaced case the
same applies unless the row value is 0, in which case the row just handled was
the last one from one of the preceding passes.  Because interlacing may skip a
pass you cannot be sure that the preceding pass is just 'pass-1'; if you really
need to know what the last pass is record (row,pass) from the callback and use
the last recorded value each time.

As with the user transform you can find the output row using the
<a href="png.h.html#L2506">PNG_ROW_FROM_PASS_ROW</a> macro.

Unknown-chunk handling

Now you get to set the way the library processes unknown chunks in the
input PNG stream. Both known and unknown chunks will be read.  Normal
behavior is that known chunks will be parsed into information in
various info_ptr members while unknown chunks will be discarded. This
behavior can be wasteful if your application will never use some known
chunk types. To change this, you can call:

    <a href="png.h.html#L2310">png_set_keep_unknown_chunks</a>(png_ptr, keep,
        chunk_list, num_chunks);

    keep       - 0: default unknown chunk handling
                 1: ignore; do not keep
                 2: keep only if safe-to-copy
                 3: keep even if unsafe-to-copy

               You can use these definitions:
                 <a href="png.h.html#L2376">PNG_HANDLE_CHUNK_AS_DEFAULT</a>   0
                 <a href="png.h.html#L2377">PNG_HANDLE_CHUNK_NEVER</a>        1
                 <a href="png.h.html#L2378">PNG_HANDLE_CHUNK_IF_SAFE</a>      2
                 <a href="png.h.html#L2379">PNG_HANDLE_CHUNK_ALWAYS</a>       3

    chunk_list - list of chunks affected (a byte string,
                 five bytes per chunk, NULL or '\0' if
                 num_chunks is positive; ignored if
                 numchunks &lt;= 0).

    num_chunks - number of chunks affected; if 0, all
                 unknown chunks are affected.  If positive,
                 only the chunks in the list are affected,
                 and if negative all unknown chunks and
                 all known chunks except for the IHDR,
                 PLTE, tRNS, IDAT, and IEND chunks are
                 affected.

Unknown chunks declared in this way will be saved as raw data onto a
list of png_unknown_chunk structures.  If a chunk that is normally
known to libpng is named in the list, it will be handled as unknown,
according to the "keep" directive.  If a chunk is named in successive
instances of <a href="png.h.html#L2310">png_set_keep_unknown_chunks</a>(), the final instance will
take precedence.  The IHDR and IEND chunks should not be named in
chunk_list; if they are, libpng will process them normally anyway.
If you know that your application will never make use of some particular
chunks, use <a href="png.h.html#L2377">PNG_HANDLE_CHUNK_NEVER</a> (or 1) as demonstrated below.

Here is an example of the usage of <a href="png.h.html#L2310">png_set_keep_unknown_chunks</a>(),
where the private "vpAg" chunk will later be processed by a user chunk
callback function:

    png_byte vpAg[5]={118, 112,  65, 103, (png_byte) '\0'};

    #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
      png_byte unused_chunks[]=
      {
        104,  73,  83,  84, (png_byte) '\0',   /* hIST */
        105,  84,  88, 116, (png_byte) '\0',   /* iTXt */
        112,  67,  65,  76, (png_byte) '\0',   /* pCAL */
        115,  67,  65,  76, (png_byte) '\0',   /* sCAL */
        115,  80,  76,  84, (png_byte) '\0',   /* sPLT */
        116,  73,  77,  69, (png_byte) '\0',   /* tIME */
      };
    #endif

    ...

    #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
      /* ignore all unknown chunks
       * (use global setting "2" for libpng16 and earlier):
       */
      <a href="png.h.html#L2310">png_set_keep_unknown_chunks</a>(read_ptr, 2, NULL, 0);

      /* except for vpAg: */
      <a href="png.h.html#L2310">png_set_keep_unknown_chunks</a>(read_ptr, 2, vpAg, 1);

      /* also ignore unused known chunks: */
      <a href="png.h.html#L2310">png_set_keep_unknown_chunks</a>(read_ptr, 1, unused_chunks,
         (int)(sizeof unused_chunks)/5);
    #endif

User limits

The PNG specification allows the width and height of an image to be as
large as 2^31-1 (0x7fffffff), or about 2.147 billion rows and columns.
For safety, libpng imposes a default limit of 1 million rows and columns.
Larger images will be rejected immediately with a png_error() call. If
you wish to change these limits, you can use

   <a href="png.h.html#L2392">png_set_user_limits</a>(png_ptr, width_max, height_max);

to set your own limits (libpng may reject some very wide images
anyway because of potential buffer overflow conditions).

You should put this statement after you create the PNG structure and
before calling <a href="png.h.html#L1053">png_read_info</a>(), <a href="png.h.html#L2352">png_read_png</a>(), or <a href="png.h.html#L1718">png_process_data</a>().

When writing a PNG datastream, put this statement before calling
<a href="png.h.html#L1048">png_write_info</a>() or <a href="png.h.html#L2356">png_write_png</a>().

If you need to retrieve the limits that are being applied, use

   width_max = <a href="png.h.html#L2394">png_get_user_width_max</a>(png_ptr);
   height_max = <a href="png.h.html#L2396">png_get_user_height_max</a>(png_ptr);

The PNG specification sets no limit on the number of ancillary chunks
allowed in a PNG datastream.  By default, libpng imposes a limit of
a total of 1000 sPLT, tEXt, iTXt, zTXt, and unknown chunks to be stored.
If you have set up both info_ptr and end_info_ptr, the limit applies
separately to each.  You can change the limit on the total number of such
chunks that will be stored, with

   <a href="png.h.html#L2399">png_set_chunk_cache_max</a>(png_ptr, user_chunk_cache_max);

where 0x7fffffffL means unlimited.  You can retrieve this limit with

   chunk_cache_max = <a href="png.h.html#L2401">png_get_chunk_cache_max</a>(png_ptr);

Libpng imposes a limit of 8 Megabytes (8,000,000 bytes) on the amount of
memory that any chunk other than IDAT can occupy, originally or when
decompressed (prior to libpng-1.6.32 the limit was only applied to compressed
chunks after decompression). You can change this limit with

   <a href="png.h.html#L2404">png_set_chunk_malloc_max</a>(png_ptr, user_chunk_malloc_max);

and you can retrieve the limit with

   chunk_malloc_max = <a href="png.h.html#L2406">png_get_chunk_malloc_max</a>(png_ptr);

Any chunks that would cause either of these limits to be exceeded will
be ignored.

Information about your system

If you intend to display the PNG or to incorporate it in other image data you
need to tell libpng information about your display or drawing surface so that
libpng can convert the values in the image to match the display.

From libpng-1.5.4 this information can be set before reading the PNG file
header.  In earlier versions png_set_gamma() existed but behaved incorrectly if
called before the PNG file header had been read and png_set_alpha_mode() did not
exist.

If you need to support versions prior to libpng-1.5.4 test the version number
as illustrated below using "<a href="png.h.html#L352">PNG_LIBPNG_VER</a> &gt;= 10504" and follow the procedures
described in the appropriate manual page.

You give libpng the encoding expected by your system expressed as a 'gamma'
value.  You can also specify a default encoding for the PNG file in
case the required information is missing from the file.  By default libpng
assumes that the PNG data matches your system, to keep this default call:

   png_set_gamma(png_ptr, screen_gamma, output_gamma);

or you can use the fixed point equivalent:

   png_set_gamma_fixed(png_ptr, <a href="png.h.html#L687">PNG_FP_1</a>*screen_gamma,
      <a href="png.h.html#L687">PNG_FP_1</a>*output_gamma);

If you don't know the gamma for your system it is probably 2.2 - a good
approximation to the IEC standard for display systems (sRGB).  If images are
too contrasty or washed out you got the value wrong - check your system
documentation!

Many systems permit the system gamma to be changed via a lookup table in the
display driver, a few systems, including older Macs, change the response by
default.  As of 1.5.4 three special values are available to handle common
situations:

   <a href="png.h.html#L1178">PNG_DEFAULT_sRGB</a>: Indicates that the system conforms to the
                     IEC 61966-2-1 standard.  This matches almost
                     all systems.
   <a href="png.h.html#L1179">PNG_GAMMA_MAC_18</a>: Indicates that the system is an older
                     (pre Mac OS 10.6) Apple Macintosh system with
                     the default settings.
   <a href="png.h.html#L1181">PNG_GAMMA_LINEAR</a>: Just the fixed point value for 1.0 - indicates
                     that the system expects data with no gamma
                     encoding.

You would use the linear (unencoded) value if you need to process the pixel
values further because this avoids the need to decode and re-encode each
component value whenever arithmetic is performed.  A lot of graphics software
uses linear values for this reason, often with higher precision component values
to preserve overall accuracy.


The output_gamma value expresses how to decode the output values, not how
they are encoded.  The values used correspond to the normal numbers used to
describe the overall gamma of a computer display system; for example 2.2 for
an sRGB conformant system.  The values are scaled by 100000 in the _fixed
version of the API (so 220000 for sRGB.)

The inverse of the value is always used to provide a default for the PNG file
encoding if it has no gAMA chunk and if png_set_gamma() has not been called
to override the PNG gamma information.

When the ALPHA_OPTIMIZED mode is selected the output gamma is used to encode
opaque pixels however pixels with lower alpha values are not encoded,
regardless of the output gamma setting.

When the standard Porter Duff handling is requested with mode 1 the output
encoding is set to be linear and the output_gamma value is only relevant
as a default for input data that has no gamma information.  The linear output
encoding will be overridden if png_set_gamma() is called - the results may be
highly unexpected!

The following numbers are derived from the sRGB standard and the research
behind it.  sRGB is defined to be approximated by a PNG gAMA chunk value of
0.45455 (1/2.2) for PNG.  The value implicitly includes any viewing
correction required to take account of any differences in the color
environment of the original scene and the intended display environment; the
value expresses how to *decode* the image for display, not how the original
data was *encoded*.

sRGB provides a peg for the PNG standard by defining a viewing environment.
sRGB itself, and earlier TV standards, actually use a more complex transform
(a linear portion then a gamma 2.4 power law) than PNG can express.  (PNG is
limited to simple power laws.)  By saying that an image for direct display on
an sRGB conformant system should be stored with a gAMA chunk value of 45455
(11.3.3.2 and 11.3.3.5 of the ISO PNG specification) the PNG specification
makes it possible to derive values for other display systems and
environments.

The Mac value is deduced from the sRGB based on an assumption that the actual
extra viewing correction used in early Mac display systems was implemented as
a power 1.45 lookup table.

Any system where a programmable lookup table is used or where the behavior of
the final display device characteristics can be changed requires system
specific code to obtain the current characteristic.  However this can be
difficult and most PNG gamma correction only requires an approximate value.

By default, if png_set_alpha_mode() is not called, libpng assumes that all
values are unencoded, linear, values and that the output device also has a
linear characteristic.  This is only very rarely correct - it is invariably
better to call png_set_alpha_mode() with <a href="png.h.html#L1178">PNG_DEFAULT_sRGB</a> than rely on the
default if you don't know what the right answer is!

The special value <a href="png.h.html#L1179">PNG_GAMMA_MAC_18</a> indicates an older Mac system (pre Mac OS
10.6) which used a correction table to implement a somewhat lower gamma on an
otherwise sRGB system.

Both these values are reserved (not simple gamma values) in order to allow
more precise correction internally in the future.

NOTE: the values can be passed to either the fixed or floating
point APIs, but the floating point API will also accept floating point
values.

The second thing you may need to tell libpng about is how your system handles
alpha channel information.  Some, but not all, PNG files contain an alpha
channel.  To display these files correctly you need to compose the data onto a
suitable background, as described in the PNG specification.

Libpng only supports composing onto a single color (using png_set_background;
see below).  Otherwise you must do the composition yourself and, in this case,
you may need to call png_set_alpha_mode:

   #if <a href="png.h.html#L352">PNG_LIBPNG_VER</a> &gt;= 10504
      png_set_alpha_mode(png_ptr, mode, screen_gamma);
   #else
      png_set_gamma(png_ptr, screen_gamma, 1.0/screen_gamma);
   #endif

The screen_gamma value is the same as the argument to png_set_gamma; however,
how it affects the output depends on the mode.  png_set_alpha_mode() sets the
file gamma default to 1/screen_gamma, so normally you don't need to call
png_set_gamma.  If you need different defaults call png_set_gamma() before
png_set_alpha_mode() - if you call it after it will override the settings made
by png_set_alpha_mode().

The mode is as follows:

    <a href="png.h.html#L1161">PNG_ALPHA_PNG</a>: The data is encoded according to the PNG
specification.  Red, green and blue, or gray, components are
gamma encoded color values and are not premultiplied by the
alpha value.  The alpha value is a linear measure of the
contribution of the pixel to the corresponding final output pixel.

You should normally use this format if you intend to perform
color correction on the color values; most, maybe all, color
correction software has no handling for the alpha channel and,
anyway, the math to handle pre-multiplied component values is
unnecessarily complex.

Before you do any arithmetic on the component values you need
to remove the gamma encoding and multiply out the alpha
channel.  See the PNG specification for more detail.  It is
important to note that when an image with an alpha channel is
scaled, linear encoded, pre-multiplied component values must
be used!

The remaining modes assume you don't need to do any further color correction or
that if you do, your color correction software knows all about alpha (it
probably doesn't!).  They 'associate' the alpha with the color information by
storing color channel values that have been scaled by the alpha.  The
advantage is that the color channels can be resampled (the image can be
scaled) in this form.  The disadvantage is that normal practice is to store
linear, not (gamma) encoded, values and this requires 16-bit channels for
still images rather than the 8-bit channels that are just about sufficient if
gamma encoding is used.  In addition all non-transparent pixel values,
including completely opaque ones, must be gamma encoded to produce the final
image.  These are the 'STANDARD', 'ASSOCIATED' or 'PREMULTIPLIED' modes
described below (the latter being the two common names for associated alpha
color channels). Note that PNG files always contain non-associated color
channels; png_set_alpha_mode() with one of the modes causes the decoder to
convert the pixels to an associated form before returning them to your
application. 

Since it is not necessary to perform arithmetic on opaque color values so
long as they are not to be resampled and are in the final color space it is
possible to optimize the handling of alpha by storing the opaque pixels in
the PNG format (adjusted for the output color space) while storing partially
opaque pixels in the standard, linear, format.  The accuracy required for
standard alpha composition is relatively low, because the pixels are
isolated, therefore typically the accuracy loss in storing 8-bit linear
values is acceptable.  (This is not true if the alpha channel is used to
simulate transparency over large areas - use 16 bits or the PNG mode in
this case!)  This is the 'OPTIMIZED' mode.  For this mode a pixel is
treated as opaque only if the alpha value is equal to the maximum value.

    <a href="png.h.html#L1162">PNG_ALPHA_STANDARD</a>:  The data libpng produces is encoded in the
standard way assumed by most correctly written graphics software.
The gamma encoding will be removed by libpng and the
linear component values will be pre-multiplied by the
alpha channel.

With this format the final image must be re-encoded to
match the display gamma before the image is displayed.
If your system doesn't do that, yet still seems to
perform arithmetic on the pixels without decoding them,
it is broken - check out the modes below.

With <a href="png.h.html#L1162">PNG_ALPHA_STANDARD</a> libpng always produces linear
component values, whatever screen_gamma you supply.  The
screen_gamma value is, however, used as a default for
the file gamma if the PNG file has no gamma information.

If you call png_set_gamma() after png_set_alpha_mode() you
will override the linear encoding.  Instead the
pre-multiplied pixel values will be gamma encoded but
the alpha channel will still be linear.  This may
actually match the requirements of some broken software,
but it is unlikely.

While linear 8-bit data is often used it has
insufficient precision for any image with a reasonable
dynamic range.  To avoid problems, and if your software
supports it, use <a href="png.h.html#L1092">png_set_expand_16</a>() to force all
components to 16 bits.

    <a href="png.h.html#L1165">PNG_ALPHA_OPTIMIZED</a>: This mode is the same as <a href="png.h.html#L1162">PNG_ALPHA_STANDARD</a>
except that completely opaque pixels are gamma encoded according to
the screen_gamma value.  Pixels with alpha less than 1.0
will still have linear components.

Use this format if you have control over your
compositing software and so don't do other arithmetic
(such as scaling) on the data you get from libpng.  Your
compositing software can simply copy opaque pixels to
the output but still has linear values for the
non-opaque pixels.

In normal compositing, where the alpha channel encodes
partial pixel coverage (as opposed to broad area
translucency), the inaccuracies of the 8-bit
representation of non-opaque pixels are irrelevant.

You can also try this format if your software is broken;
it might look better.

    <a href="png.h.html#L1166">PNG_ALPHA_BROKEN</a>: This is <a href="png.h.html#L1162">PNG_ALPHA_STANDARD</a>; however, all component
values, including the alpha channel are gamma encoded.  This is
broken because, in practice, no implementation that uses this choice
correctly undoes the encoding before handling alpha composition.  Use this
choice only if other serious errors in the software or hardware you use
mandate it.  In most cases of broken software or hardware the bug in the
final display manifests as a subtle halo around composited parts of the
image.  You may not even perceive this as a halo; the composited part of
the image may simply appear separate from the background, as though it had
been cut out of paper and pasted on afterward.

If you don't have to deal with bugs in software or hardware, or if you can fix
them, there are three recommended ways of using png_set_alpha_mode():

   png_set_alpha_mode(png_ptr, <a href="png.h.html#L1161">PNG_ALPHA_PNG</a>,
       screen_gamma);

You can do color correction on the result (libpng does not currently
support color correction internally).  When you handle the alpha channel
you need to undo the gamma encoding and multiply out the alpha.

   png_set_alpha_mode(png_ptr, <a href="png.h.html#L1162">PNG_ALPHA_STANDARD</a>,
       screen_gamma);
   <a href="png.h.html#L1092">png_set_expand_16</a>(png_ptr);

If you are using the high level interface, don't call <a href="png.h.html#L1092">png_set_expand_16</a>();
instead pass <a href="png.h.html#L882">PNG_TRANSFORM_EXPAND_16</a> to the interface.

With this mode you can't do color correction, but you can do arithmetic,
including composition and scaling, on the data without further processing.

   png_set_alpha_mode(png_ptr, <a href="png.h.html#L1165">PNG_ALPHA_OPTIMIZED</a>,
       screen_gamma);

You can avoid the expansion to 16-bit components with this mode, but you
lose the ability to scale the image or perform other linear arithmetic.
All you can do is compose the result onto a matching output.  Since this
mode is libpng-specific you also need to write your own composition
software.

The following are examples of calls to png_set_alpha_mode to achieve the
required overall gamma correction and, where necessary, alpha
premultiplication.

    png_set_alpha_mode(pp, <a href="png.h.html#L1161">PNG_ALPHA_PNG</a>, <a href="png.h.html#L1178">PNG_DEFAULT_sRGB</a>);

Choices for the alpha_mode are

    <a href="png.h.html#L1161">PNG_ALPHA_PNG</a>           0 /* according to the PNG standard */
    <a href="png.h.html#L1162">PNG_ALPHA_STANDARD</a>      1 /* according to Porter/Duff */
    <a href="png.h.html#L1163">PNG_ALPHA_ASSOCIATED</a>    1 /* as above; this is the normal practice */
    <a href="png.h.html#L1164">PNG_ALPHA_PREMULTIPLIED</a> 1 /* as above */
    <a href="png.h.html#L1165">PNG_ALPHA_OPTIMIZED</a>     2 /* 'PNG' for opaque pixels, else 'STANDARD' */
    <a href="png.h.html#L1166">PNG_ALPHA_BROKEN</a>        3 /* the alpha channel is gamma encoded */

<a href="png.h.html#L1161">PNG_ALPHA_PNG</a> is the default libpng handling of the alpha channel. It is not
pre-multiplied into the color components. In addition the call states
that the output is for a sRGB system and causes all PNG files without gAMA
chunks to be assumed to be encoded using sRGB.

    png_set_alpha_mode(pp, <a href="png.h.html#L1161">PNG_ALPHA_PNG</a>, PNG_GAMMA_MAC);

In this case the output is assumed to be something like an sRGB conformant
display preceeded by a power-law lookup table of power 1.45.  This is how
early Mac systems behaved.

    png_set_alpha_mode(pp, <a href="png.h.html#L1162">PNG_ALPHA_STANDARD</a>, <a href="png.h.html#L1181">PNG_GAMMA_LINEAR</a>);

This is the classic Jim Blinn approach and will work in academic
environments where everything is done by the book.  It has the shortcoming
of assuming that input PNG data with no gamma information is linear - this
is unlikely to be correct unless the PNG files were generated locally.
Most of the time the output precision will be so low as to show
significant banding in dark areas of the image.

    <a href="png.h.html#L1092">png_set_expand_16</a>(pp);
    png_set_alpha_mode(pp, <a href="png.h.html#L1162">PNG_ALPHA_STANDARD</a>, <a href="png.h.html#L1178">PNG_DEFAULT_sRGB</a>);

This is a somewhat more realistic Jim Blinn inspired approach.  PNG files
are assumed to have the sRGB encoding if not marked with a gamma value and
the output is always 16 bits per component.  This permits accurate scaling
and processing of the data.  If you know that your input PNG files were
generated locally you might need to replace <a href="png.h.html#L1178">PNG_DEFAULT_sRGB</a> with the
correct value for your system.

    png_set_alpha_mode(pp, <a href="png.h.html#L1165">PNG_ALPHA_OPTIMIZED</a>, <a href="png.h.html#L1178">PNG_DEFAULT_sRGB</a>);

If you just need to composite the PNG image onto an existing background
and if you control the code that does this you can use the optimization
setting.  In this case you just copy completely opaque pixels to the
output.  For pixels that are not completely transparent (you just skip
those) you do the composition math using png_composite or png_composite_16
below then encode the resultant 8-bit or 16-bit values to match the output
encoding.

    Other cases

If neither the PNG nor the standard linear encoding work for you because
of the software or hardware you use then you have a big problem.  The PNG
case will probably result in halos around the image.  The linear encoding
will probably result in a washed out, too bright, image (it's actually too
contrasty.)  Try the ALPHA_OPTIMIZED mode above - this will probably
substantially reduce the halos.  Alternatively try:

    png_set_alpha_mode(pp, <a href="png.h.html#L1166">PNG_ALPHA_BROKEN</a>, <a href="png.h.html#L1178">PNG_DEFAULT_sRGB</a>);

This option will also reduce the halos, but there will be slight dark
halos round the opaque parts of the image where the background is light.
In the OPTIMIZED mode the halos will be light halos where the background
is dark.  Take your pick - the halos are unavoidable unless you can get
your hardware/software fixed!  (The OPTIMIZED approach is slightly
faster.)

When the default gamma of PNG files doesn't match the output gamma.
If you have PNG files with no gamma information png_set_alpha_mode allows
you to provide a default gamma, but it also sets the ouput gamma to the
matching value.  If you know your PNG files have a gamma that doesn't
match the output you can take advantage of the fact that
png_set_alpha_mode always sets the output gamma but only sets the PNG
default if it is not already set:

    png_set_alpha_mode(pp, <a href="png.h.html#L1161">PNG_ALPHA_PNG</a>, <a href="png.h.html#L1178">PNG_DEFAULT_sRGB</a>);
    png_set_alpha_mode(pp, <a href="png.h.html#L1161">PNG_ALPHA_PNG</a>, PNG_GAMMA_MAC);

The first call sets both the default and the output gamma values, the
second call overrides the output gamma without changing the default.  This
is easier than achieving the same effect with png_set_gamma.  You must use
<a href="png.h.html#L1161">PNG_ALPHA_PNG</a> for the first call - internal checking in png_set_alpha will
fire if more than one call to png_set_alpha_mode and png_set_background is
made in the same read operation, however multiple calls with <a href="png.h.html#L1161">PNG_ALPHA_PNG</a>
are ignored.

If you don't need, or can't handle, the alpha channel you can call
png_set_background() to remove it by compositing against a fixed color.  Don't
call <a href="png.h.html#L1261">png_set_strip_alpha</a>() to do this - it will leave spurious pixel values in
transparent parts of this image.

   png_set_background(png_ptr, &amp;background_color,
       <a href="png.h.html#L1339">PNG_BACKGROUND_GAMMA_SCREEN</a>, 0, 1);

The background_color is an RGB or grayscale value according to the data format
libpng will produce for you.  Because you don't yet know the format of the PNG
file, if you call png_set_background at this point you must arrange for the
format produced by libpng to always have 8-bit or 16-bit components and then
store the color as an 8-bit or 16-bit color as appropriate.  The color contains
separate gray and RGB component values, so you can let libpng produce gray or
RGB output according to the input format, but low bit depth grayscale images
must always be converted to at least 8-bit format.  (Even though low bit depth
grayscale images can't have an alpha channel they can have a transparent
color!)

You set the transforms you need later, either as flags to the high level
interface or libpng API calls for the low level interface.  For reference the
settings and API calls required are:

8-bit values:
   <a href="png.h.html#L884">PNG_TRANSFORM_SCALE_16</a> | PNG_EXPAND
   <a href="png.h.html#L1082">png_set_expand</a>(png_ptr); <a href="png.h.html#L1346">png_set_scale_16</a>(png_ptr);

   If you must get exactly the same inaccurate results
   produced by default in versions prior to libpng-1.5.4,
   use <a href="png.h.html#L864">PNG_TRANSFORM_STRIP_16</a> and <a href="png.h.html#L1352">png_set_strip_16</a>(png_ptr)
   instead.

16-bit values:
   <a href="png.h.html#L882">PNG_TRANSFORM_EXPAND_16</a>
   <a href="png.h.html#L1092">png_set_expand_16</a>(png_ptr);

In either case palette image data will be expanded to RGB.  If you just want
color data you can add <a href="png.h.html#L880">PNG_TRANSFORM_GRAY_TO_RGB</a> or <a href="png.h.html#L1102">png_set_gray_to_rgb</a>(png_ptr)
to the list.

Calling png_set_background before the PNG file header is read will not work
prior to libpng-1.5.4.  Because the failure may result in unexpected warnings or
errors it is therefore much safer to call png_set_background after the head has
been read.  Unfortunately this means that prior to libpng-1.5.4 it cannot be
used with the high level interface.

The high-level read interface

At this point there are two ways to proceed; through the high-level
read interface, or through a sequence of low-level read operations.
You can use the high-level interface if (a) you are willing to read
the entire image into memory, and (b) the input transformations
you want to do are limited to the following set:

    <a href="png.h.html#L863">PNG_TRANSFORM_IDENTITY</a>      No transformation
    <a href="png.h.html#L884">PNG_TRANSFORM_SCALE_16</a>      Strip 16-bit samples to
                                8-bit accurately
    <a href="png.h.html#L864">PNG_TRANSFORM_STRIP_16</a>      Chop 16-bit samples to
                                8-bit less accurately
    <a href="png.h.html#L865">PNG_TRANSFORM_STRIP_ALPHA</a>   Discard the alpha channel
    <a href="png.h.html#L866">PNG_TRANSFORM_PACKING</a>       Expand 1, 2 and 4-bit
                                samples to bytes
    <a href="png.h.html#L867">PNG_TRANSFORM_PACKSWAP</a>      Change order of packed
                                pixels to LSB first
    <a href="png.h.html#L868">PNG_TRANSFORM_EXPAND</a>        Perform set_expand()
    <a href="png.h.html#L869">PNG_TRANSFORM_INVERT_MONO</a>   Invert monochrome images
    <a href="png.h.html#L870">PNG_TRANSFORM_SHIFT</a>         Normalize pixels to the
                                sBIT depth
    <a href="png.h.html#L871">PNG_TRANSFORM_BGR</a>           Flip RGB to BGR, RGBA
                                to BGRA
    <a href="png.h.html#L872">PNG_TRANSFORM_SWAP_ALPHA</a>    Flip RGBA to ARGB or GA
                                to AG
    <a href="png.h.html#L874">PNG_TRANSFORM_INVERT_ALPHA</a>  Change alpha from opacity
                                to transparency
    <a href="png.h.html#L873">PNG_TRANSFORM_SWAP_ENDIAN</a>   Byte-swap 16-bit samples
    <a href="png.h.html#L880">PNG_TRANSFORM_GRAY_TO_RGB</a>   Expand grayscale samples
                                to RGB (or GA to RGBA)
    <a href="png.h.html#L882">PNG_TRANSFORM_EXPAND_16</a>     Expand samples to 16 bits

(This excludes setting a background color, doing gamma transformation,
quantizing, and setting filler.)  If this is the case, simply do this:

    <a href="png.h.html#L2352">png_read_png</a>(png_ptr, info_ptr, png_transforms, NULL)

where png_transforms is an integer containing the bitwise OR of some
set of transformation flags.  This call is equivalent to <a href="png.h.html#L1053">png_read_info</a>(),
followed the set of transformations indicated by the transform mask,
then <a href="png.h.html#L1415">png_read_image</a>(), and finally <a href="png.h.html#L1439">png_read_end</a>().

(The final parameter of this call is not yet used.  Someday it might point
to transformation parameters required by some future input transform.)

You must use png_transforms and not call any png_set_transform() functions
when you use <a href="png.h.html#L2352">png_read_png</a>().

After you have called <a href="png.h.html#L2352">png_read_png</a>(), you can retrieve the image data
with

   row_pointers = <a href="png.h.html#L1880">png_get_rows</a>(png_ptr, info_ptr);

where row_pointers is an array of pointers to the pixel data for each row:

   png_bytep row_pointers[height];

If you know your image size and pixel size ahead of time, you can allocate
row_pointers prior to calling <a href="png.h.html#L2352">png_read_png</a>() with

   if (height &gt; <a href="png.h.html#L681">PNG_UINT_32_MAX</a>/(sizeof (png_byte)))
      png_error (png_ptr,
          "Image is too tall to process in memory");

   if (width &gt; <a href="png.h.html#L681">PNG_UINT_32_MAX</a>/pixel_size)
      png_error (png_ptr,
          "Image is too wide to process in memory");

   row_pointers = png_malloc(png_ptr,
       height*(sizeof (png_bytep)));

   for (int i=0; i&lt;height, i++)
      row_pointers[i]=NULL;  /* security precaution */

   for (int i=0; i&lt;height, i++)
      row_pointers[i]=png_malloc(png_ptr,
          width*pixel_size);

   <a href="png.h.html#L1886">png_set_rows</a>(png_ptr, info_ptr, &amp;row_pointers);

Alternatively you could allocate your image in one big block and define
row_pointers[i] to point into the proper places in your block, but first
be sure that your platform is able to allocate such a large buffer:

   /* Guard against integer overflow */
   if (height &gt; <a href="png.h.html#L682">PNG_SIZE_MAX</a>/(width*pixel_size)) {
        png_error(png_ptr,"image_data buffer would be too large");
   }

   png_bytep buffer=png_malloc(png_ptr,height*width*pixel_size);

   for (int i=0; i&lt;height, i++)
      row_pointers[i]=buffer+i*width*pixel_size;

   <a href="png.h.html#L1886">png_set_rows</a>(png_ptr, info_ptr, &amp;row_pointers);

If you use <a href="png.h.html#L1886">png_set_rows</a>(), the application is responsible for freeing
row_pointers (and row_pointers[i], if they were separately allocated).

If you don't allocate row_pointers ahead of time, <a href="png.h.html#L2352">png_read_png</a>() will
do it, and it'll be free'ed by libpng when you call png_destroy_*().

The low-level read interface

If you are going the low-level route, you are now ready to read all
the file information up to the actual image data.  You do this with a
call to <a href="png.h.html#L1053">png_read_info</a>().

    <a href="png.h.html#L1053">png_read_info</a>(png_ptr, info_ptr);

This will process all chunks up to but not including the image data.

This also copies some of the data from the PNG file into the decode structure
for use in later transformations.  Important information copied in is:

1) The PNG file gamma from the gAMA chunk.  This overwrites the default value
provided by an earlier call to png_set_gamma or png_set_alpha_mode.

2) Prior to libpng-1.5.4 the background color from a bKGd chunk.  This
damages the information provided by an earlier call to png_set_background
resulting in unexpected behavior.  Libpng-1.5.4 no longer does this.

3) The number of significant bits in each component value.  Libpng uses this to
optimize gamma handling by reducing the internal lookup table sizes.

4) The transparent color information from a tRNS chunk.  This can be modified by
a later call to <a href="png.h.html#L2177">png_set_tRNS</a>.

Querying the info structure

Functions are used to get the information from the info_ptr once it
has been read.  Note that these fields may not be completely filled
in until <a href="png.h.html#L1439">png_read_end</a>() has read the chunk data following the image.

    <a href="png.h.html#L2046">png_get_IHDR</a>(png_ptr, info_ptr, &amp;width, &amp;height,
       &amp;bit_depth, &amp;color_type, &amp;interlace_type,
       &amp;compression_type, &amp;filter_method);

    width          - holds the width of the image
                     in pixels (up to 2^31).

    height         - holds the height of the image
                     in pixels (up to 2^31).

    bit_depth      - holds the bit depth of one of the
                     image channels.  (valid values are
                     1, 2, 4, 8, 16 and depend also on
                     the color_type.  See also
                     significant bits (sBIT) below).

    color_type     - describes which color/alpha channels
                         are present.
                     <a href="png.h.html#L699">PNG_COLOR_TYPE_GRAY</a>
                        (bit depths 1, 2, 4, 8, 16)
                     <a href="png.h.html#L703">PNG_COLOR_TYPE_GRAY_ALPHA</a>
                        (bit depths 8, 16)
                     <a href="png.h.html#L700">PNG_COLOR_TYPE_PALETTE</a>
                        (bit depths 1, 2, 4, 8)
                     <a href="png.h.html#L701">PNG_COLOR_TYPE_RGB</a>
                        (bit_depths 8, 16)
                     <a href="png.h.html#L702">PNG_COLOR_TYPE_RGB_ALPHA</a>
                        (bit_depths 8, 16)

                     <a href="png.h.html#L694">PNG_COLOR_MASK_PALETTE</a>
                     <a href="png.h.html#L695">PNG_COLOR_MASK_COLOR</a>
                     <a href="png.h.html#L696">PNG_COLOR_MASK_ALPHA</a>

    interlace_type - (<a href="png.h.html#L718">PNG_INTERLACE_NONE</a> or
                     <a href="png.h.html#L719">PNG_INTERLACE_ADAM7</a>)

    compression_type - (must be <a href="png.h.html#L709">PNG_COMPRESSION_TYPE_BASE</a>
                     for PNG 1.0)

    filter_method  - (must be <a href="png.h.html#L713">PNG_FILTER_TYPE_BASE</a>
                     for PNG 1.0, and can also be
                     <a href="png.h.html#L714">PNG_INTRAPIXEL_DIFFERENCING</a> if
                     the PNG datastream is embedded in
                     a MNG-1.0 datastream)

    Any of width, height, color_type, bit_depth,
    interlace_type, compression_type, or filter_method can
    be NULL if you are not interested in their values.

    Note that <a href="png.h.html#L2046">png_get_IHDR</a>() returns 32-bit data into
    the application's width and height variables.
    This is an unsafe situation if these are not png_uint_32
    variables.  In such situations, the
    <a href="png.h.html#L1896">png_get_image_width</a>() and <a href="png.h.html#L1900">png_get_image_height</a>()
    functions described below are safer.

    width            = <a href="png.h.html#L1896">png_get_image_width</a>(png_ptr,
                         info_ptr);

    height           = <a href="png.h.html#L1900">png_get_image_height</a>(png_ptr,
                         info_ptr);

    bit_depth        = <a href="png.h.html#L1904">png_get_bit_depth</a>(png_ptr,
                         info_ptr);

    color_type       = <a href="png.h.html#L1908">png_get_color_type</a>(png_ptr,
                         info_ptr);

    interlace_type   = <a href="png.h.html#L1916">png_get_interlace_type</a>(png_ptr,
                         info_ptr);

    compression_type = <a href="png.h.html#L1920">png_get_compression_type</a>(png_ptr,
                         info_ptr);

    filter_method    = <a href="png.h.html#L1912">png_get_filter_type</a>(png_ptr,
                         info_ptr);

    channels = <a href="png.h.html#L1891">png_get_channels</a>(png_ptr, info_ptr);

    channels       - number of channels of info for the
                     color type (valid values are 1 (GRAY,
                     PALETTE), 2 (GRAY_ALPHA), 3 (RGB),
                     4 (RGB_ALPHA or RGB + filler byte))

    rowbytes = <a href="png.h.html#L1873">png_get_rowbytes</a>(png_ptr, info_ptr);

    rowbytes       - number of bytes needed to hold a row
                     This value, the bit_depth, color_type,
                     and the number of channels can change
                     if you use transforms such as
                     <a href="png.h.html#L1082">png_set_expand</a>(). See
                     <a href="png.h.html#L1398">png_read_update_info</a>(), below.

    signature = <a href="png.h.html#L1951">png_get_signature</a>(png_ptr, info_ptr);

    signature      - holds the signature read from the
                     file (if any).  The data is kept in
                     the same offset it would be if the
                     whole signature were read (i.e. if an
                     application had already read in 4
                     bytes of signature before starting
                     libpng, the remaining 4 bytes would
                     be in signature[4] through signature[7]
                     (see <a href="png.h.html#L937">png_set_sig_bytes</a>())).

These are also important, but their validity depends on whether the chunk
has been read.  The <a href="png.h.html#L1869">png_get_valid</a>(png_ptr, info_ptr, PNG_INFO_&lt;chunk&gt;) and
png_get_&lt;chunk&gt;(png_ptr, info_ptr, ...) functions return non-zero if the
data has been read, or zero if it is missing.  The parameters to the
png_get_&lt;chunk&gt; are set directly if they are simple data types, or a
pointer into the info_ptr is returned for any complex types.

The colorspace data from gAMA, cHRM, sRGB, iCCP, and sBIT chunks
is simply returned to give the application information about how the
image was encoded.  Libpng itself only does transformations using the file
gamma when combining semitransparent pixels with the background color, and,
since libpng-1.6.0, when converting between 8-bit sRGB and 16-bit linear pixels
within the simplified API.  Libpng also uses the file gamma when converting
RGB to gray, beginning with libpng-1.0.5, if the application calls
png_set_rgb_to_gray()).

    <a href="png.h.html#L2092">png_get_PLTE</a>(png_ptr, info_ptr, &amp;palette,
                     &amp;num_palette);

    palette        - the palette for the file
                     (array of png_color)

    num_palette    - number of entries in the palette

    png_get_gAMA(png_ptr, info_ptr, &amp;file_gamma);
    png_get_gAMA_fixed(png_ptr, info_ptr, &amp;int_file_gamma);

    file_gamma     - the gamma at which the file is
                     written (<a href="png.h.html#L763">PNG_INFO_gAMA</a>)

    int_file_gamma - 100,000 times the gamma at which the
                     file is written

    png_get_cHRM(png_ptr, info_ptr,  &amp;white_x, &amp;white_y, &amp;red_x,
                     &amp;red_y, &amp;green_x, &amp;green_y, &amp;blue_x, &amp;blue_y)
    png_get_cHRM_XYZ(png_ptr, info_ptr, &amp;red_X, &amp;red_Y, &amp;red_Z,
                     &amp;green_X, &amp;green_Y, &amp;green_Z, &amp;blue_X, &amp;blue_Y,
                     &amp;blue_Z)
    png_get_cHRM_fixed(png_ptr, info_ptr, &amp;int_white_x,
                     &amp;int_white_y, &amp;int_red_x, &amp;int_red_y,
                     &amp;int_green_x, &amp;int_green_y, &amp;int_blue_x,
                     &amp;int_blue_y)
    png_get_cHRM_XYZ_fixed(png_ptr, info_ptr, &amp;int_red_X, &amp;int_red_Y,
                     &amp;int_red_Z, &amp;int_green_X, &amp;int_green_Y,
                     &amp;int_green_Z, &amp;int_blue_X, &amp;int_blue_Y,
                     &amp;int_blue_Z)

    {white,red,green,blue}_{x,y}
                     A color space encoding specified using the
                     chromaticities of the end points and the
                     white point. (<a href="png.h.html#L765">PNG_INFO_cHRM</a>)

    {red,green,blue}_{X,Y,Z}
                     A color space encoding specified using the
                     encoding end points - the CIE tristimulus
                     specification of the intended color of the red,
                     green and blue channels in the PNG RGB data.
                     The white point is simply the sum of the three
                     end points. (<a href="png.h.html#L765">PNG_INFO_cHRM</a>)

    <a href="png.h.html#L2109">png_get_sRGB</a>(png_ptr, info_ptr, &amp;srgb_intent);

    srgb_intent -    the rendering intent (<a href="png.h.html#L774">PNG_INFO_sRGB</a>)
                     The presence of the sRGB chunk
                     means that the pixel data is in the
                     sRGB color space.  This chunk also
                     implies specific values of gAMA and
                     cHRM.

    <a href="png.h.html#L2121">png_get_iCCP</a>(png_ptr, info_ptr, &amp;name,
       &amp;compression_type, &amp;profile, &amp;proflen);

    name             - The profile name.

    compression_type - The compression type; always
                       <a href="png.h.html#L709">PNG_COMPRESSION_TYPE_BASE</a> for PNG 1.0.
                       You may give NULL to this argument to
                       ignore it.

    profile          - International Color Consortium color
                       profile data. May contain NULs.

    proflen          - length of profile data in bytes.

    <a href="png.h.html#L2099">png_get_sBIT</a>(png_ptr, info_ptr, &amp;sig_bit);

    sig_bit        - the number of significant bits for
                     (<a href="png.h.html#L764">PNG_INFO_sBIT</a>) each of the gray,
                     red, green, and blue channels,
                     whichever are appropriate for the
                     given color type (png_color_16)

    <a href="png.h.html#L2171">png_get_tRNS</a>(png_ptr, info_ptr, &amp;trans_alpha,
                     &amp;num_trans, &amp;trans_color);

    trans_alpha    - array of alpha (transparency)
                     entries for palette (<a href="png.h.html#L767">PNG_INFO_tRNS</a>)

    num_trans      - number of transparent entries
                     (<a href="png.h.html#L767">PNG_INFO_tRNS</a>)

    trans_color    - graylevel or color sample values of
                     the single transparent color for
                     non-paletted images (<a href="png.h.html#L767">PNG_INFO_tRNS</a>)

    <a href="png.h.html#L2018">png_get_eXIf_1</a>(png_ptr, info_ptr, &amp;num_exif, &amp;exif);
                     (<a href="png.h.html#L779">PNG_INFO_eXIf</a>)

    exif           - Exif profile (array of png_byte)

    <a href="png.h.html#L2040">png_get_hIST</a>(png_ptr, info_ptr, &amp;hist);
                     (<a href="png.h.html#L769">PNG_INFO_hIST</a>)

    hist           - histogram of palette (array of
                     png_uint_16)

    <a href="png.h.html#L2161">png_get_tIME</a>(png_ptr, info_ptr, &amp;mod_time);

    mod_time       - time image was last modified
                    (PNG_VALID_tIME)

    <a href="png.h.html#L1956">png_get_bKGD</a>(png_ptr, info_ptr, &amp;background);

    background     - background color (of type
                     png_color_16p) (PNG_VALID_bKGD)
                     valid 16-bit red, green and blue
                     values, regardless of color_type

    num_comments   = <a href="png.h.html#L2144">png_get_text</a>(png_ptr, info_ptr,
                     &amp;text_ptr, &amp;num_text);

    num_comments   - number of comments

    text_ptr       - array of png_text holding image
                     comments

    text_ptr[i].compression - type of compression used
                 on "text" <a href="png.h.html#L619">PNG_TEXT_COMPRESSION_NONE</a>
                           <a href="png.h.html#L620">PNG_TEXT_COMPRESSION_zTXt</a>
                           <a href="png.h.html#L621">PNG_ITXT_COMPRESSION_NONE</a>
                           <a href="png.h.html#L622">PNG_ITXT_COMPRESSION_zTXt</a>

    text_ptr[i].key   - keyword for comment.  Must contain
                         1-79 characters.

    text_ptr[i].text  - text comments for current
                         keyword.  Can be empty.

    text_ptr[i].text_length - length of text string,
                 after decompression, 0 for iTXt

    text_ptr[i].itxt_length - length of itxt string,
                 after decompression, 0 for tEXt/zTXt

    text_ptr[i].lang  - language of comment (empty
                         string for unknown).

    text_ptr[i].lang_key  - keyword in UTF-8
                         (empty string for unknown).

    Note that the itxt_length, lang, and lang_key
    members of the text_ptr structure only exist when the
    library is built with iTXt chunk support.  Prior to
    libpng-1.4.0 the library was built by default without
    iTXt support. Also note that when iTXt is supported,
    they contain NULL pointers when the "compression"
    field contains <a href="png.h.html#L619">PNG_TEXT_COMPRESSION_NONE</a> or
    <a href="png.h.html#L620">PNG_TEXT_COMPRESSION_zTXt</a>.

    num_text       - number of comments (same as
                     num_comments; you can put NULL here
                     to avoid the duplication)

    Note while <a href="png.h.html#L2156">png_set_text</a>() will accept text, language,
    and translated keywords that can be NULL pointers, the
    structure returned by <a href="png.h.html#L2144">png_get_text</a> will always contain
    regular zero-terminated C strings.  They might be
    empty strings but they will never be NULL pointers.

    num_spalettes = <a href="png.h.html#L2133">png_get_sPLT</a>(png_ptr, info_ptr,
       &amp;palette_ptr);

    num_spalettes  - number of sPLT chunks read.

    palette_ptr    - array of palette structures holding
                     contents of one or more sPLT chunks
                     read.

    <a href="png.h.html#L2057">png_get_oFFs</a>(png_ptr, info_ptr, &amp;offset_x, &amp;offset_y,
       &amp;unit_type);

    offset_x       - positive offset from the left edge
                     of the screen (can be negative)

    offset_y       - positive offset from the top edge
                     of the screen (can be negative)

    unit_type      - <a href="png.h.html#L723">PNG_OFFSET_PIXEL</a>, <a href="png.h.html#L724">PNG_OFFSET_MICROMETER</a>

    <a href="png.h.html#L2082">png_get_pHYs</a>(png_ptr, info_ptr, &amp;res_x, &amp;res_y,
       &amp;unit_type);

    res_x          - pixels/unit physical resolution in
                     x direction

    res_y          - pixels/unit physical resolution in
                     x direction

    unit_type      - <a href="png.h.html#L741">PNG_RESOLUTION_UNKNOWN</a>,
                     <a href="png.h.html#L742">PNG_RESOLUTION_METER</a>

    png_get_sCAL(png_ptr, info_ptr, &amp;unit, &amp;width,
       &amp;height)

    unit        - physical scale units (an integer)

    width       - width of a pixel in physical scale units

    height      - height of a pixel in physical scale units
                 (width and height are doubles)

    <a href="png.h.html#L2196">png_get_sCAL_s</a>(png_ptr, info_ptr, &amp;unit, &amp;width,
       &amp;height)

    unit        - physical scale units (an integer)

    width       - width of a pixel in physical scale units
                  (expressed as a string)

    height      - height of a pixel in physical scale units
                 (width and height are strings like "2.54")

    num_unknown_chunks = <a href="png.h.html#L2338">png_get_unknown_chunks</a>(png_ptr,
       info_ptr, &amp;unknowns)

    unknowns          - array of png_unknown_chunk
                        structures holding unknown chunks

    unknowns[i].name  - name of unknown chunk

    unknowns[i].data  - data of unknown chunk

    unknowns[i].size  - size of unknown chunk's data

    unknowns[i].location - position of chunk in file

    The value of "i" corresponds to the order in which the
    chunks were read from the PNG file or inserted with the
    <a href="png.h.html#L2323">png_set_unknown_chunks</a>() function.

    The value of "location" is a bitwise "or" of

         <a href="png.h.html#L675">PNG_HAVE_IHDR</a>  (0x01)
         <a href="png.h.html#L676">PNG_HAVE_PLTE</a>  (0x02)
         <a href="png.h.html#L677">PNG_AFTER_IDAT</a> (0x08)

The data from the pHYs chunk can be retrieved in several convenient
forms:

    res_x = <a href="png.h.html#L1926">png_get_x_pixels_per_meter</a>(png_ptr,
       info_ptr)

    res_y = <a href="png.h.html#L1928">png_get_y_pixels_per_meter</a>(png_ptr,
       info_ptr)

    res_x_and_y = <a href="png.h.html#L1924">png_get_pixels_per_meter</a>(png_ptr,
       info_ptr)

    res_x = <a href="png.h.html#L2414">png_get_x_pixels_per_inch</a>(png_ptr,
       info_ptr)

    res_y = <a href="png.h.html#L2417">png_get_y_pixels_per_inch</a>(png_ptr,
       info_ptr)

    res_x_and_y = <a href="png.h.html#L2411">png_get_pixels_per_inch</a>(png_ptr,
       info_ptr)

    aspect_ratio = png_get_pixel_aspect_ratio(png_ptr,
       info_ptr)

    Each of these returns 0 [signifying "unknown"] if
       the data is not present or if res_x is 0;
       res_x_and_y is 0 if res_x != res_y

    Note that because of the way the resolutions are
       stored internally, the inch conversions won't
       come out to exactly even number.  For example,
       72 dpi is stored as 0.28346 pixels/meter, and
       when this is retrieved it is 71.9988 dpi, so
       be sure to round the returned value appropriately
       if you want to display a reasonable-looking result.

The data from the oFFs chunk can be retrieved in several convenient
forms:

    x_offset = <a href="png.h.html#L1942">png_get_x_offset_microns</a>(png_ptr, info_ptr);

    y_offset = <a href="png.h.html#L1944">png_get_y_offset_microns</a>(png_ptr, info_ptr);

    x_offset = png_get_x_offset_inches(png_ptr, info_ptr);

    y_offset = png_get_y_offset_inches(png_ptr, info_ptr);

    Each of these returns 0 [signifying "unknown" if both
       x and y are 0] if the data is not present or if the
       chunk is present but the unit is the pixel.  The
       remark about inexact inch conversions applies here
       as well, because a value in inches can't always be
       converted to microns and back without some loss
       of precision.

For more information, see the
PNG specification for chunk contents.  Be careful with trusting
rowbytes, as some of the transformations could increase the space
needed to hold a row (expand, filler, gray_to_rgb, etc.).
See <a href="png.h.html#L1398">png_read_update_info</a>(), below.

A quick word about text_ptr and num_text.  PNG stores comments in
keyword/text pairs, one pair per chunk, with no limit on the number
of text chunks, and a 2^31 byte limit on their size.  While there are
suggested keywords, there is no requirement to restrict the use to these
strings.  It is strongly suggested that keywords and text be sensible
to humans (that's the point), so don't use abbreviations.  Non-printing
symbols are not allowed.  See the PNG specification for more details.
There is also no requirement to have text after the keyword.

Keywords should be limited to 79 Latin-1 characters without leading or
trailing spaces, but non-consecutive spaces are allowed within the
keyword.  It is possible to have the same keyword any number of times.
The text_ptr is an array of png_text structures, each holding a
pointer to a language string, a pointer to a keyword and a pointer to
a text string.  The text string, language code, and translated
keyword may be empty or NULL pointers.  The keyword/text
pairs are put into the array in the order that they are received.
However, some or all of the text chunks may be after the image, so, to
make sure you have read all the text chunks, don't mess with these
until after you read the stuff after the image.  This will be
mentioned again below in the discussion that goes with <a href="png.h.html#L1439">png_read_end</a>().

Input transformations

After you've read the header information, you can set up the library
to handle any special transformations of the image data.  The various
ways to transform the data will be described in the order that they
should occur.  This is important, as some of these change the color
type and/or bit depth of the data, and some others only work on
certain color types and bit depths.

Transformations you request are ignored if they don't have any meaning for a
particular input data format.  However some transformations can have an effect
as a result of a previous transformation.  If you specify a contradictory set of
transformations, for example both adding and removing the alpha channel, you
cannot predict the final result.

The color used for the transparency values should be supplied in the same
format/depth as the current image data.  It is stored in the same format/depth
as the image data in a tRNS chunk, so this is what libpng expects for this data.

The color used for the background value depends on the need_expand argument as
described below.

Data will be decoded into the supplied row buffers packed into bytes
unless the library has been told to transform it into another format.
For example, 4 bit/pixel paletted or grayscale data will be returned
2 pixels/byte with the leftmost pixel in the high-order bits of the byte,
unless <a href="png.h.html#L1293">png_set_packing</a>() is called.  8-bit RGB data will be stored
in RGB RGB RGB format unless <a href="png.h.html#L1276">png_set_filler</a>() or <a href="png.h.html#L1282">png_set_add_alpha</a>()
is called to insert filler bytes, either before or after each RGB triplet.

16-bit RGB data will be returned RRGGBB RRGGBB, with the most significant
byte of the color value first, unless <a href="png.h.html#L1346">png_set_scale_16</a>() is called to
transform it to regular RGB RGB triplets, or <a href="png.h.html#L1276">png_set_filler</a>() or
png_set_add alpha() is called to insert two filler bytes, either before
or after each RRGGBB triplet.  Similarly, 8-bit or 16-bit grayscale data can
be modified with <a href="png.h.html#L1276">png_set_filler</a>(), <a href="png.h.html#L1282">png_set_add_alpha</a>(), <a href="png.h.html#L1352">png_set_strip_16</a>(),
or <a href="png.h.html#L1346">png_set_scale_16</a>().

The following code transforms grayscale images of less than 8 to 8 bits,
changes paletted images to RGB, and adds a full alpha channel if there is
transparency information in a tRNS chunk.  This is most useful on
grayscale images with bit depths of 2 or 4 or if there is a multiple-image
viewing application that wishes to treat all images in the same way.

    if (color_type == <a href="png.h.html#L700">PNG_COLOR_TYPE_PALETTE</a>)
        <a href="png.h.html#L1084">png_set_palette_to_rgb</a>(png_ptr);

    if (<a href="png.h.html#L1869">png_get_valid</a>(png_ptr, info_ptr,
        <a href="png.h.html#L767">PNG_INFO_tRNS</a>)) <a href="png.h.html#L1085">png_set_tRNS_to_alpha</a>(png_ptr);

    if (color_type == <a href="png.h.html#L699">PNG_COLOR_TYPE_GRAY</a> &amp;&amp;
        bit_depth &lt; 8) <a href="png.h.html#L1083">png_set_expand_gray_1_2_4_to_8</a>(png_ptr);

The first two functions are actually aliases for <a href="png.h.html#L1082">png_set_expand</a>(), added
in libpng version 1.0.4, with the function names expanded to improve code
readability.  In some future version they may actually do different
things.

As of libpng version 1.2.9, <a href="png.h.html#L1083">png_set_expand_gray_1_2_4_to_8</a>() was
added.  It expands the sample depth without changing tRNS to alpha.

As of libpng version 1.5.2, <a href="png.h.html#L1092">png_set_expand_16</a>() was added.  It behaves as
<a href="png.h.html#L1082">png_set_expand</a>(); however, the resultant channels have 16 bits rather than 8.
Use this when the output color or gray channels are made linear to avoid fairly
severe accuracy loss.

   if (bit_depth &lt; 16)
      <a href="png.h.html#L1092">png_set_expand_16</a>(png_ptr);

PNG can have files with 16 bits per channel.  If you only can handle
8 bits per channel, this will strip the pixels down to 8-bit.

    if (bit_depth == 16)
#if <a href="png.h.html#L352">PNG_LIBPNG_VER</a> &gt;= 10504
       <a href="png.h.html#L1346">png_set_scale_16</a>(png_ptr);
#else
       <a href="png.h.html#L1352">png_set_strip_16</a>(png_ptr);
#endif

(The more accurate "<a href="png.h.html#L1346">png_set_scale_16</a>()" API became available in libpng version
1.5.4).

If you need to process the alpha channel on the image separately from the image
data (for example if you convert it to a bitmap mask) it is possible to have
libpng strip the channel leaving just RGB or gray data:

    if (color_type &amp; <a href="png.h.html#L696">PNG_COLOR_MASK_ALPHA</a>)
       <a href="png.h.html#L1261">png_set_strip_alpha</a>(png_ptr);

If you strip the alpha channel you need to find some other way of dealing with
the information.  If, instead, you want to convert the image to an opaque
version with no alpha channel use png_set_background; see below.

As of libpng version 1.5.2, almost all useful expansions are supported, the
major ommissions are conversion of grayscale to indexed images (which can be
done trivially in the application) and conversion of indexed to grayscale (which
can be done by a trivial manipulation of the palette.)

In the following table, the 01 means grayscale with depth&lt;8, 31 means
indexed with depth&lt;8, other numerals represent the color type, "T" means
the tRNS chunk is present, A means an alpha channel is present, and O
means tRNS or alpha is present but all pixels in the image are opaque.

  FROM  01  31   0  0T  0O   2  2T  2O   3  3T  3O  4A  4O  6A  6O
   TO
   01    -  [G]  -   -   -   -   -   -   -   -   -   -   -   -   -
   31   [Q]  Q  [Q] [Q] [Q]  Q   Q   Q   Q   Q   Q  [Q] [Q]  Q   Q
    0    1   G   +   .   .   G   G   G   G   G   G   B   B  GB  GB
   0T    lt  Gt  t   +   .   Gt  G   G   Gt  G   G   Bt  Bt GBt GBt
   0O    lt  Gt  t   .   +   Gt  Gt  G   Gt  Gt  G   Bt  Bt GBt GBt
    2    C   P   C   C   C   +   .   .   C   -   -  CB  CB   B   B
   2T    Ct  -   Ct  C   C   t   +   t   -   -   -  CBt CBt  Bt  Bt
   2O    Ct  -   Ct  C   C   t   t   +   -   -   -  CBt CBt  Bt  Bt
    3   [Q]  p  [Q] [Q] [Q]  Q   Q   Q   +   .   .  [Q] [Q]  Q   Q
   3T   [Qt] p  [Qt][Q] [Q]  Qt  Qt  Qt  t   +   t  [Qt][Qt] Qt  Qt
   3O   [Qt] p  [Qt][Q] [Q]  Qt  Qt  Qt  t   t   +  [Qt][Qt] Qt  Qt
   4A    lA  G   A   T   T   GA  GT  GT  GA  GT  GT  +   BA  G  GBA
   4O    lA GBA  A   T   T   GA  GT  GT  GA  GT  GT  BA  +  GBA  G
   6A    CA  PA  CA  C   C   A   T  tT   PA  P   P   C  CBA  +   BA
   6O    CA PBA  CA  C   C   A  tT   T   PA  P   P  CBA  C   BA  +

Within the matrix,
     "+" identifies entries where 'from' and 'to' are the same.
     "-" means the transformation is not supported.
     "." means nothing is necessary (a tRNS chunk can just be ignored).
     "t" means the transformation is obtained by <a href="png.h.html#L2177">png_set_tRNS</a>.
     "A" means the transformation is obtained by <a href="png.h.html#L1282">png_set_add_alpha</a>().
     "X" means the transformation is obtained by <a href="png.h.html#L1082">png_set_expand</a>().
     "1" means the transformation is obtained by
         <a href="png.h.html#L1083">png_set_expand_gray_1_2_4_to_8</a>() (and by <a href="png.h.html#L1082">png_set_expand</a>()
         if there is no transparency in the original or the final
         format).
     "C" means the transformation is obtained by <a href="png.h.html#L1102">png_set_gray_to_rgb</a>().
     "G" means the transformation is obtained by png_set_rgb_to_gray().
     "P" means the transformation is obtained by
         png_set_expand_palette_to_rgb().
     "p" means the transformation is obtained by <a href="png.h.html#L1293">png_set_packing</a>().
     "Q" means the transformation is obtained by <a href="png.h.html#L1359">png_set_quantize</a>().
     "T" means the transformation is obtained by
         <a href="png.h.html#L1085">png_set_tRNS_to_alpha</a>().
     "B" means the transformation is obtained by
         png_set_background(), or png_strip_alpha().

When an entry has multiple transforms listed all are required to cause the
right overall transformation.  When two transforms are separated by a comma
either will do the job.  When transforms are enclosed in [] the transform should
do the job but this is currently unimplemented - a different format will result
if the suggested transformations are used.

In PNG files, the alpha channel in an image
is the level of opacity.  If you need the alpha channel in an image to
be the level of transparency instead of opacity, you can invert the
alpha channel (or the tRNS chunk data) after it's read, so that 0 is
fully opaque and 255 (in 8-bit or paletted images) or 65535 (in 16-bit
images) is fully transparent, with

    <a href="png.h.html#L1271">png_set_invert_alpha</a>(png_ptr);

PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
they can, resulting in, for example, 8 pixels per byte for 1 bit
files.  This code expands to 1 pixel per byte without changing the
values of the pixels:

    if (bit_depth &lt; 8)
       <a href="png.h.html#L1293">png_set_packing</a>(png_ptr);

PNG files have possible bit depths of 1, 2, 4, 8, and 16.  All pixels
stored in a PNG image have been "scaled" or "shifted" up to the next
higher possible bit depth (e.g. from 5 bits/sample in the range [0,31]
to 8 bits/sample in the range [0, 255]).  However, it is also possible
to convert the PNG pixel data back to the original bit depth of the
image.  This call reduces the pixels back down to the original bit depth:

    png_color_8p sig_bit;

    if (<a href="png.h.html#L2099">png_get_sBIT</a>(png_ptr, info_ptr, &amp;sig_bit))
       <a href="png.h.html#L1304">png_set_shift</a>(png_ptr, sig_bit);

PNG files store 3-color pixels in red, green, blue order.  This code
changes the storage of the pixels to blue, green, red:

    if (color_type == <a href="png.h.html#L701">PNG_COLOR_TYPE_RGB</a> ||
        color_type == <a href="png.h.html#L702">PNG_COLOR_TYPE_RGB_ALPHA</a>)
       <a href="png.h.html#L1097">png_set_bgr</a>(png_ptr);

PNG files store RGB pixels packed into 3 or 6 bytes. This code expands them
into 4 or 8 bytes for windowing systems that need them in this format:

    if (color_type == <a href="png.h.html#L701">PNG_COLOR_TYPE_RGB</a>)
       <a href="png.h.html#L1276">png_set_filler</a>(png_ptr, filler, <a href="png.h.html#L1279">PNG_FILLER_BEFORE</a>);

where "filler" is the 8-bit or 16-bit number to fill with, and the location
is either <a href="png.h.html#L1279">PNG_FILLER_BEFORE</a> or <a href="png.h.html#L1280">PNG_FILLER_AFTER</a>, depending upon whether
you want the filler before the RGB or after. When filling an 8-bit pixel,
the least significant 8 bits of the number are used, if a 16-bit number is
supplied.  This transformation does not affect images that already have full
alpha channels.  To add an opaque alpha channel, use filler=0xffff and
<a href="png.h.html#L1280">PNG_FILLER_AFTER</a> which will generate RGBA pixels.

Note that <a href="png.h.html#L1276">png_set_filler</a>() does not change the color type.  If you want
to do that, you can add a true alpha channel with

    if (color_type == <a href="png.h.html#L701">PNG_COLOR_TYPE_RGB</a> ||
       color_type == <a href="png.h.html#L699">PNG_COLOR_TYPE_GRAY</a>)
       <a href="png.h.html#L1282">png_set_add_alpha</a>(png_ptr, filler, <a href="png.h.html#L1280">PNG_FILLER_AFTER</a>);

where "filler" contains the alpha value to assign to each pixel.
The <a href="png.h.html#L1282">png_set_add_alpha</a>() function was added in libpng-1.2.7.

If you are reading an image with an alpha channel, and you need the
data as ARGB instead of the normal PNG format RGBA:

    if (color_type == <a href="png.h.html#L702">PNG_COLOR_TYPE_RGB_ALPHA</a>)
       <a href="png.h.html#L1266">png_set_swap_alpha</a>(png_ptr);

For some uses, you may want a grayscale image to be represented as
RGB.  This code will do that conversion:

    if (color_type == <a href="png.h.html#L699">PNG_COLOR_TYPE_GRAY</a> ||
        color_type == <a href="png.h.html#L703">PNG_COLOR_TYPE_GRAY_ALPHA</a>)
       <a href="png.h.html#L1102">png_set_gray_to_rgb</a>(png_ptr);

Conversely, you can convert an RGB or RGBA image to grayscale or grayscale
with alpha.

    if (color_type == <a href="png.h.html#L701">PNG_COLOR_TYPE_RGB</a> ||
        color_type == <a href="png.h.html#L702">PNG_COLOR_TYPE_RGB_ALPHA</a>)
       png_set_rgb_to_gray(png_ptr, error_action,
          double red_weight, double green_weight);

    error_action = 1: silently do the conversion

    error_action = 2: issue a warning if the original
                      image has any pixel where
                      red != green or red != blue

    error_action = 3: issue an error and abort the
                      conversion if the original
                      image has any pixel where
                      red != green or red != blue

    red_weight:       weight of red component

    green_weight:     weight of green component
                      If either weight is negative, default
                      weights are used.

In the corresponding fixed point API the red_weight and green_weight values are
simply scaled by 100,000:

    png_set_rgb_to_gray(png_ptr, error_action,
       png_fixed_point red_weight,
       png_fixed_point green_weight);

If you have set error_action = 1 or 2, you can
later check whether the image really was gray, after processing
the image rows, with the <a href="png.h.html#L1117">png_get_rgb_to_gray_status</a>(png_ptr) function.
It will return a png_byte that is zero if the image was gray or
1 if there were any non-gray pixels.  Background and sBIT data
will be silently converted to grayscale, using the green channel
data for sBIT, regardless of the error_action setting.

The default values come from the PNG file cHRM chunk if present; otherwise, the
defaults correspond to the ITU-R recommendation 709, and also the sRGB color
space, as recommended in the Charles Poynton's Colour FAQ,
Copyright (c) 2006-11-28 Charles Poynton, in section 9:

&lt;http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html#RTFToC9&gt;

    Y = 0.2126 * R + 0.7152 * G + 0.0722 * B

Previous versions of this document, 1998 through 2002, recommended a slightly
different formula:

    Y = 0.212671 * R + 0.715160 * G + 0.072169 * B

Libpng uses an integer approximation:

    Y = (6968 * R + 23434 * G + 2366 * B)/32768

The calculation is done in a linear colorspace, if the image gamma
can be determined.

The png_set_background() function has been described already; it tells libpng to
composite images with alpha or simple transparency against the supplied
background color.  For compatibility with versions of libpng earlier than
libpng-1.5.4 it is recommended that you call the function after reading the file
header, even if you don't want to use the color in a bKGD chunk, if one exists.

If the PNG file contains a bKGD chunk (<a href="png.h.html#L768">PNG_INFO_bKGD</a> valid),
you may use this color, or supply another color more suitable for
the current display (e.g., the background color from a web page).  You
need to tell libpng how the color is represented, both the format of the
component values in the color (the number of bits) and the gamma encoding of the
color.  The function takes two arguments, background_gamma_mode and need_expand
to convey this information; however, only two combinations are likely to be
useful:

    png_color_16 my_background;
    png_color_16p image_background;

    if (<a href="png.h.html#L1956">png_get_bKGD</a>(png_ptr, info_ptr, &amp;image_background))
       png_set_background(png_ptr, image_background,
           <a href="png.h.html#L1340">PNG_BACKGROUND_GAMMA_FILE</a>, 1/*needs to be expanded*/, 1);
    else
       png_set_background(png_ptr, &amp;my_background,
           <a href="png.h.html#L1339">PNG_BACKGROUND_GAMMA_SCREEN</a>, 0/*do not expand*/, 1);

The second call was described above - my_background is in the format of the
final, display, output produced by libpng.  Because you now know the format of
the PNG it is possible to avoid the need to choose either 8-bit or 16-bit
output and to retain palette images (the palette colors will be modified
appropriately and the tRNS chunk removed.)  However, if you are doing this,
take great care not to ask for transformations without checking first that
they apply!

In the first call the background color has the original bit depth and color type
of the PNG file.  So, for palette images the color is supplied as a palette
index and for low bit greyscale images the color is a reduced bit value in
image_background-&gt;gray.

If you didn't call png_set_gamma() before reading the file header, for example
if you need your code to remain compatible with older versions of libpng prior
to libpng-1.5.4, this is the place to call it.

Do not call it if you called png_set_alpha_mode(); doing so will damage the
settings put in place by png_set_alpha_mode().  (If png_set_alpha_mode() is
supported then you can certainly do png_set_gamma() before reading the PNG
header.)

This API unconditionally sets the screen and file gamma values, so it will
override the value in the PNG file unless it is called before the PNG file
reading starts.  For this reason you must always call it with the PNG file
value when you call it in this position:

   if (png_get_gAMA(png_ptr, info_ptr, &amp;file_gamma))
      png_set_gamma(png_ptr, screen_gamma, file_gamma);

   else
      png_set_gamma(png_ptr, screen_gamma, 0.45455);

If you need to reduce an RGB file to a paletted file, or if a paletted
file has more entries than will fit on your screen, <a href="png.h.html#L1359">png_set_quantize</a>()
will do that.  Note that this is a simple match quantization that merely
finds the closest color available.  This should work fairly well with
optimized palettes, but fairly badly with linear color cubes.  If you
pass a palette that is larger than maximum_colors, the file will
reduce the number of colors in the palette so it will fit into
maximum_colors.  If there is a histogram, libpng will use it to make
more intelligent choices when reducing the palette.  If there is no
histogram, it may not do as good a job.

   if (color_type &amp; <a href="png.h.html#L695">PNG_COLOR_MASK_COLOR</a>)
   {
      if (<a href="png.h.html#L1869">png_get_valid</a>(png_ptr, info_ptr,
          <a href="png.h.html#L766">PNG_INFO_PLTE</a>))
      {
         png_uint_16p histogram = NULL;

         <a href="png.h.html#L2040">png_get_hIST</a>(png_ptr, info_ptr,
             &amp;histogram);
         <a href="png.h.html#L1359">png_set_quantize</a>(png_ptr, palette, num_palette,
            max_screen_colors, histogram, 1);
      }

      else
      {
         png_color std_color_cube[MAX_SCREEN_COLORS] =
            { ... colors ... };

         <a href="png.h.html#L1359">png_set_quantize</a>(png_ptr, std_color_cube,
            MAX_SCREEN_COLORS, MAX_SCREEN_COLORS,
            NULL,0);
      }
   }

PNG files describe monochrome as black being zero and white being one.
The following code will reverse this (make black be one and white be
zero):

   if (bit_depth == 1 &amp;&amp; color_type == <a href="png.h.html#L699">PNG_COLOR_TYPE_GRAY</a>)
      <a href="png.h.html#L1321">png_set_invert_mono</a>(png_ptr);

This function can also be used to invert grayscale and gray-alpha images:

   if (color_type == <a href="png.h.html#L699">PNG_COLOR_TYPE_GRAY</a> ||
       color_type == <a href="png.h.html#L703">PNG_COLOR_TYPE_GRAY_ALPHA</a>)
      <a href="png.h.html#L1321">png_set_invert_mono</a>(png_ptr);

PNG files store 16-bit pixels in network byte order (big-endian,
ie. most significant bits first).  This code changes the storage to the
other way (little-endian, i.e. least significant bits first, the
way PCs store them):

    if (bit_depth == 16)
       <a href="png.h.html#L1288">png_set_swap</a>(png_ptr);

If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
need to change the order the pixels are packed into bytes, you can use:

    if (bit_depth &lt; 8)
       <a href="png.h.html#L1299">png_set_packswap</a>(png_ptr);

Finally, you can write your own transformation function if none of
the existing ones meets your needs.  This is done by setting a callback
with

    <a href="png.h.html#L1643">png_set_read_user_transform_fn</a>(png_ptr,
        read_transform_fn);

You must supply the function

    void read_transform_fn(png_structp png_ptr, png_row_infop
        row_info, png_bytep data)

See pngtest.c for a working example.  Your function will be called
after all of the other transformations have been processed.  Take care with
interlaced images if you do the interlace yourself - the width of the row is the
width in 'row_info', not the overall image width.

If supported, libpng provides two information routines that you can use to find
where you are in processing the image:

   <a href="png.h.html#L1674">png_get_current_pass_number</a>(png_structp png_ptr);
   <a href="png.h.html#L1673">png_get_current_row_number</a>(png_structp png_ptr);

Don't try using these outside a transform callback - firstly they are only
supported if user transforms are supported, secondly they may well return
unexpected results unless the row is actually being processed at the moment they
are called.

With interlaced
images the value returned is the row in the input sub-image image.  Use
<a href="png.h.html#L2506">PNG_ROW_FROM_PASS_ROW</a>(row, pass) and <a href="png.h.html#L2508">PNG_COL_FROM_PASS_COL</a>(col, pass) to
find the output pixel (x,y) given an interlaced sub-image pixel (row,col,pass).

The discussion of interlace handling above contains more information on how to
use these values.

You can also set up a pointer to a user structure for use by your
callback function, and you can inform libpng that your transform
function will change the number of channels or bit depth with the
function

    <a href="png.h.html#L1653">png_set_user_transform_info</a>(png_ptr, user_ptr,
        user_depth, user_channels);

The user's application, not libpng, is responsible for allocating and
freeing any memory required for the user structure.

You can retrieve the pointer via the function
<a href="png.h.html#L1657">png_get_user_transform_ptr</a>().  For example:

    voidp read_user_transform_ptr =
        <a href="png.h.html#L1657">png_get_user_transform_ptr</a>(png_ptr);

The last thing to handle is interlacing; this is covered in detail below,
but you must call the function here if you want libpng to handle expansion
of the interlaced image.

    number_of_passes = <a href="png.h.html#L1316">png_set_interlace_handling</a>(png_ptr);

After setting the transformations, libpng can update your png_info
structure to reflect any transformations you've requested with this
call.

    <a href="png.h.html#L1398">png_read_update_info</a>(png_ptr, info_ptr);

This is most useful to update the info structure's rowbytes
field so you can use it to allocate your image memory.  This function
will also update your palette with the correct screen_gamma and
background if these have been given with the calls above.  You may
only call <a href="png.h.html#L1398">png_read_update_info</a>() once with a particular info_ptr.

After you call <a href="png.h.html#L1398">png_read_update_info</a>(), you can allocate any
memory you need to hold the image.  The row data is simply
raw byte data for all forms of images.  As the actual allocation
varies among applications, no example will be given.  If you
are allocating one large chunk, you will need to build an
array of pointers to each row, as it will be needed for some
of the functions below.

Be sure that your platform can allocate the buffer that you'll need.
libpng internally checks for oversize width, but you'll need to
do your own check for number_of_rows*width*pixel_size if you are using
a multiple-row buffer:

   /* Guard against integer overflow */
   if (number_of_rows &gt; <a href="png.h.html#L682">PNG_SIZE_MAX</a>/(width*pixel_size)) {
        png_error(png_ptr,"image_data buffer would be too large");
   }

Remember: Before you call <a href="png.h.html#L1398">png_read_update_info</a>(), the png_get_*()
functions return the values corresponding to the original PNG image.
After you call <a href="png.h.html#L1398">png_read_update_info</a> the values refer to the image
that libpng will output.  Consequently you must call all the png_set_
functions before you call <a href="png.h.html#L1398">png_read_update_info</a>().  This is particularly
important for <a href="png.h.html#L1316">png_set_interlace_handling</a>() - if you are going to call
<a href="png.h.html#L1398">png_read_update_info</a>() you must call <a href="png.h.html#L1316">png_set_interlace_handling</a>() before
it unless you want to receive interlaced output.

Reading image data

After you've allocated memory, you can read the image data.
The simplest way to do this is in one function call.  If you are
allocating enough memory to hold the whole image, you can just
call <a href="png.h.html#L1415">png_read_image</a>() and libpng will read in all the image data
and put it in the memory area supplied.  You will need to pass in
an array of pointers to each row.

This function automatically handles interlacing, so you don't
need to call <a href="png.h.html#L1316">png_set_interlace_handling</a>() (unless you call
<a href="png.h.html#L1398">png_read_update_info</a>()) or call this function multiple times, or any
of that other stuff necessary with <a href="png.h.html#L1403">png_read_rows</a>().

   <a href="png.h.html#L1415">png_read_image</a>(png_ptr, row_pointers);

where row_pointers is:

   png_bytep row_pointers[height];

You can point to void or char or whatever you use for pixels.

If you don't want to read in the whole image at once, you can
use <a href="png.h.html#L1403">png_read_rows</a>() instead.  If there is no interlacing (check
interlace_type == <a href="png.h.html#L718">PNG_INTERLACE_NONE</a>), this is simple:

    <a href="png.h.html#L1403">png_read_rows</a>(png_ptr, row_pointers, NULL,
        number_of_rows);

where row_pointers is the same as in the <a href="png.h.html#L1415">png_read_image</a>() call.

If you are doing this just one row at a time, you can do this with
a single row_pointer instead of an array of row_pointers:

    png_bytep row_pointer = row;
    <a href="png.h.html#L1409">png_read_row</a>(png_ptr, row_pointer, NULL);

If the file is interlaced (interlace_type != 0 in the IHDR chunk), things
get somewhat harder.  The only current (PNG Specification version 1.2)
interlacing type for PNG is (interlace_type == <a href="png.h.html#L719">PNG_INTERLACE_ADAM7</a>);
a somewhat complicated 2D interlace scheme, known as Adam7, that
breaks down an image into seven smaller images of varying size, based
on an 8x8 grid.  This number is defined (from libpng 1.5) as
<a href="png.h.html#L2468">PNG_INTERLACE_ADAM7_PASSES</a> in png.h

libpng can fill out those images or it can give them to you "as is".
It is almost always better to have libpng handle the interlacing for you.
If you want the images filled out, there are two ways to do that.  The one
mentioned in the PNG specification is to expand each pixel to cover
those pixels that have not been read yet (the "rectangle" method).
This results in a blocky image for the first pass, which gradually
smooths out as more pixels are read.  The other method is the "sparkle"
method, where pixels are drawn only in their final locations, with the
rest of the image remaining whatever colors they were initialized to
before the start of the read.  The first method usually looks better,
but tends to be slower, as there are more pixels to put in the rows.

If, as is likely, you want libpng to expand the images, call this before
calling <a href="png.h.html#L1395">png_start_read_image</a>() or <a href="png.h.html#L1398">png_read_update_info</a>():

    if (interlace_type == <a href="png.h.html#L719">PNG_INTERLACE_ADAM7</a>)
       number_of_passes
           = <a href="png.h.html#L1316">png_set_interlace_handling</a>(png_ptr);

This will return the number of passes needed.  Currently, this is seven,
but may change if another interlace type is added.  This function can be
called even if the file is not interlaced, where it will return one pass.
You then need to read the whole image 'number_of_passes' times.  Each time
will distribute the pixels from the current pass to the correct place in
the output image, so you need to supply the same rows to <a href="png.h.html#L1403">png_read_rows</a> in
each pass.

If you are not going to display the image after each pass, but are
going to wait until the entire image is read in, use the sparkle
effect.  This effect is faster and the end result of either method
is exactly the same.  If you are planning on displaying the image
after each pass, the "rectangle" effect is generally considered the
better looking one.

If you only want the "sparkle" effect, just call <a href="png.h.html#L1409">png_read_row</a>() or
<a href="png.h.html#L1403">png_read_rows</a>() as
normal, with the third parameter NULL.  Make sure you make pass over
the image number_of_passes times, and you don't change the data in the
rows between calls.  You can change the locations of the data, just
not the data.  Each pass only writes the pixels appropriate for that
pass, and assumes the data from previous passes is still valid.

    <a href="png.h.html#L1403">png_read_rows</a>(png_ptr, row_pointers, NULL,
        number_of_rows);
    or
    <a href="png.h.html#L1409">png_read_row</a>(png_ptr, row_pointers, NULL);

If you only want the first effect (the rectangles), do the same as
before except pass the row buffer in the third parameter, and leave
the second parameter NULL.

    <a href="png.h.html#L1403">png_read_rows</a>(png_ptr, NULL, row_pointers,
        number_of_rows);
    or
    <a href="png.h.html#L1409">png_read_row</a>(png_ptr, NULL, row_pointers);

If you don't want libpng to handle the interlacing details, just call
<a href="png.h.html#L1403">png_read_rows</a>() <a href="png.h.html#L2468">PNG_INTERLACE_ADAM7_PASSES</a> times to read in all the images.
Each of the images is a valid image by itself; however, you will almost
certainly need to distribute the pixels from each sub-image to the
correct place.  This is where everything gets very tricky.

If you want to retrieve the separate images you must pass the correct
number of rows to each successive call of <a href="png.h.html#L1403">png_read_rows</a>().  The calculation
gets pretty complicated for small images, where some sub-images may
not even exist because either their width or height ends up zero.
libpng provides two macros to help you in 1.5 and later versions:

   png_uint_32 width = <a href="png.h.html#L2499">PNG_PASS_COLS</a>(image_width, pass_number);
   png_uint_32 height = <a href="png.h.html#L2497">PNG_PASS_ROWS</a>(image_height, pass_number);

Respectively these tell you the width and height of the sub-image
corresponding to the numbered pass.  'pass' is in in the range 0 to 6 -
this can be confusing because the specification refers to the same passes
as 1 to 7!  Be careful, you must check both the width and height before
calling <a href="png.h.html#L1403">png_read_rows</a>() and not call it for that pass if either is zero.

You can, of course, read each sub-image row by row.  If you want to
produce optimal code to make a pixel-by-pixel transformation of an
interlaced image this is the best approach; read each row of each pass,
transform it, and write it out to a new interlaced image.

If you want to de-interlace the image yourself libpng provides further
macros to help that tell you where to place the pixels in the output image.
Because the interlacing scheme is rectangular - sub-image pixels are always
arranged on a rectangular grid - all you need to know for each pass is the
starting column and row in the output image of the first pixel plus the
spacing between each pixel.  As of libpng 1.5 there are four macros to
retrieve this information:

   png_uint_32 x = <a href="png.h.html#L2475">PNG_PASS_START_COL</a>(pass);
   png_uint_32 y = <a href="png.h.html#L2474">PNG_PASS_START_ROW</a>(pass);
   png_uint_32 xStep = 1U &lt;&lt; <a href="png.h.html#L2490">PNG_PASS_COL_SHIFT</a>(pass);
   png_uint_32 yStep = 1U &lt;&lt; <a href="png.h.html#L2489">PNG_PASS_ROW_SHIFT</a>(pass);

These allow you to write the obvious loop:

   png_uint_32 input_y = 0;
   png_uint_32 output_y = <a href="png.h.html#L2474">PNG_PASS_START_ROW</a>(pass);

   while (output_y &lt; output_image_height)
   {
      png_uint_32 input_x = 0;
      png_uint_32 output_x = <a href="png.h.html#L2475">PNG_PASS_START_COL</a>(pass);

      while (output_x &lt; output_image_width)
      {
         image[output_y][output_x] =
             subimage[pass][input_y][input_x++];

         output_x += xStep;
      }

      ++input_y;
      output_y += yStep;
   }

Notice that the steps between successive output rows and columns are
returned as shifts.  This is possible because the pixels in the subimages
are always a power of 2 apart - 1, 2, 4 or 8 pixels - in the original
image.  In practice you may need to directly calculate the output coordinate
given an input coordinate.  libpng provides two further macros for this
purpose:

   png_uint_32 output_x = <a href="png.h.html#L2508">PNG_COL_FROM_PASS_COL</a>(input_x, pass);
   png_uint_32 output_y = <a href="png.h.html#L2506">PNG_ROW_FROM_PASS_ROW</a>(input_y, pass);

Finally a pair of macros are provided to tell you if a particular image
row or column appears in a given pass:

   int col_in_pass = <a href="png.h.html#L2523">PNG_COL_IN_INTERLACE_PASS</a>(output_x, pass);
   int row_in_pass = <a href="png.h.html#L2521">PNG_ROW_IN_INTERLACE_PASS</a>(output_y, pass);

Bear in mind that you will probably also need to check the width and height
of the pass in addition to the above to be sure the pass even exists!

With any luck you are convinced by now that you don't want to do your own
interlace handling.  In reality normally the only good reason for doing this
is if you are processing PNG files on a pixel-by-pixel basis and don't want
to load the whole file into memory when it is interlaced.

libpng includes a test program, pngvalid, that illustrates reading and
writing of interlaced images.  If you can't get interlacing to work in your
code and don't want to leave it to libpng (the recommended approach), see
how pngvalid.c does it.

Finishing a sequential read

After you are finished reading the image through the
low-level interface, you can finish reading the file.

If you want to use a different crc action for handling CRC errors in
chunks after the image data, you can call <a href="png.h.html#L1455">png_set_crc_action</a>()
again at this point.

If you are interested in comments or time, which may be stored either
before or after the image data, you should pass the separate png_info
struct if you want to keep the comments from before and after the image
separate.

    png_infop end_info = png_create_info_struct(png_ptr);

    if (!end_info)
    {
       <a href="png.h.html#L1447">png_destroy_read_struct</a>(&amp;png_ptr, &amp;info_ptr,
           (png_infopp)NULL);
       return (ERROR);
    }

   <a href="png.h.html#L1439">png_read_end</a>(png_ptr, end_info);

If you are not interested, you should still call <a href="png.h.html#L1439">png_read_end</a>()
but you can pass NULL, avoiding the need to create an end_info structure.
If you do this, libpng will not process any chunks after IDAT other than
skipping over them and perhaps (depending on whether you have called
<a href="png.h.html#L1455">png_set_crc_action</a>) checking their CRCs while looking for the IEND chunk.

   <a href="png.h.html#L1439">png_read_end</a>(png_ptr, (png_infop)NULL);

If you don't call <a href="png.h.html#L1439">png_read_end</a>(), then your file pointer will be
left pointing to the first chunk after the last IDAT, which is probably
not what you want if you expect to read something beyond the end of
the PNG datastream.

When you are done, you can free all memory allocated by libpng like this:

   <a href="png.h.html#L1447">png_destroy_read_struct</a>(&amp;png_ptr, &amp;info_ptr,
       &amp;end_info);

or, if you didn't create an end_info structure,

   <a href="png.h.html#L1447">png_destroy_read_struct</a>(&amp;png_ptr, &amp;info_ptr,
       (png_infopp)NULL);

It is also possible to individually free the info_ptr members that
point to libpng-allocated storage with the following function:

    <a href="png.h.html#L1761">png_free_data</a>(png_ptr, info_ptr, mask, seq)

    mask - identifies data to be freed, a mask
           containing the bitwise OR of one or
           more of
             <a href="png.h.html#L1789">PNG_FREE_PLTE</a>, <a href="png.h.html#L1790">PNG_FREE_TRNS</a>,
             <a href="png.h.html#L1779">PNG_FREE_HIST</a>, <a href="png.h.html#L1780">PNG_FREE_ICCP</a>,
             <a href="png.h.html#L1783">PNG_FREE_PCAL</a>, <a href="png.h.html#L1782">PNG_FREE_ROWS</a>,
             <a href="png.h.html#L1784">PNG_FREE_SCAL</a>, <a href="png.h.html#L1781">PNG_FREE_SPLT</a>,
             <a href="png.h.html#L1791">PNG_FREE_TEXT</a>, <a href="png.h.html#L1786">PNG_FREE_UNKN</a>,
           or simply <a href="png.h.html#L1793">PNG_FREE_ALL</a>

    seq  - sequence number of item to be freed
           (-1 for all items)

This function may be safely called when the relevant storage has
already been freed, or has not yet been allocated, or was allocated
by the user and not by libpng,  and will in those cases do nothing.
The "seq" parameter is ignored if only one item of the selected data
type, such as PLTE, is allowed.  If "seq" is not -1, and multiple items
are allowed for the data type identified in the mask, such as text or
sPLT, only the n'th item in the structure is freed, where n is "seq".

The default behavior is only to free data that was allocated internally
by libpng.  This can be changed, so that libpng will not free the data,
or so that it will free data that was allocated by the user with png_malloc()
or png_calloc() and passed in via a png_set_*() function, with

    <a href="png.h.html#L1771">png_data_freer</a>(png_ptr, info_ptr, freer, mask)

    freer  - one of
               <a href="png.h.html#L1775">PNG_DESTROY_WILL_FREE_DATA</a>
               <a href="png.h.html#L1776">PNG_SET_WILL_FREE_DATA</a>
               <a href="png.h.html#L1777">PNG_USER_WILL_FREE_DATA</a>

    mask   - which data elements are affected
             same choices as in <a href="png.h.html#L1761">png_free_data</a>()

This function only affects data that has already been allocated.
You can call this function after reading the PNG data but before calling
any png_set_*() functions, to control whether the user or the png_set_*()
function is responsible for freeing any existing data that might be present,
and again after the png_set_*() functions to control whether the user
or png_destroy_*() is supposed to free the data.  When the user assumes
responsibility for libpng-allocated data, the application must use
<a href="png.h.html#L1758">png_free</a>() to free it, and when the user transfers responsibility to libpng
for data that the user has allocated, the user must have used png_malloc()
or png_calloc() to allocate it.

If you allocated your row_pointers in a single block, as suggested above in
the description of the high level read interface, you must not transfer
responsibility for freeing it to the <a href="png.h.html#L1886">png_set_rows</a> or png_read_destroy function,
because they would also try to free the individual row_pointers[i].

If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
separately, do not transfer responsibility for freeing text_ptr to libpng,
because when libpng fills a png_text structure it combines these members with
the key member, and <a href="png.h.html#L1761">png_free_data</a>() will free only text_ptr.key.  Similarly,
if you transfer responsibility for free'ing text_ptr from libpng to your
application, your application must not separately free those members.

The <a href="png.h.html#L1761">png_free_data</a>() function will turn off the "valid" flag for anything
it frees.  If you need to turn the flag off for a chunk that was freed by
your application instead of by libpng, you can use

    <a href="png.h.html#L2346">png_set_invalid</a>(png_ptr, info_ptr, mask);

    mask - identifies the chunks to be made invalid,
           containing the bitwise OR of one or
           more of
             <a href="png.h.html#L763">PNG_INFO_gAMA</a>, <a href="png.h.html#L764">PNG_INFO_sBIT</a>,
             <a href="png.h.html#L765">PNG_INFO_cHRM</a>, <a href="png.h.html#L766">PNG_INFO_PLTE</a>,
             <a href="png.h.html#L767">PNG_INFO_tRNS</a>, <a href="png.h.html#L768">PNG_INFO_bKGD</a>,
             <a href="png.h.html#L779">PNG_INFO_eXIf</a>,
             <a href="png.h.html#L769">PNG_INFO_hIST</a>, <a href="png.h.html#L770">PNG_INFO_pHYs</a>,
             <a href="png.h.html#L771">PNG_INFO_oFFs</a>, <a href="png.h.html#L772">PNG_INFO_tIME</a>,
             <a href="png.h.html#L773">PNG_INFO_pCAL</a>, <a href="png.h.html#L774">PNG_INFO_sRGB</a>,
             <a href="png.h.html#L775">PNG_INFO_iCCP</a>, <a href="png.h.html#L776">PNG_INFO_sPLT</a>,
             <a href="png.h.html#L777">PNG_INFO_sCAL</a>, <a href="png.h.html#L778">PNG_INFO_IDAT</a>

For a more compact example of reading a PNG image, see the file example.c.

Reading PNG files progressively

The progressive reader is slightly different from the non-progressive
reader.  Instead of calling <a href="png.h.html#L1053">png_read_info</a>(), <a href="png.h.html#L1403">png_read_rows</a>(), and
<a href="png.h.html#L1439">png_read_end</a>(), you make one call to <a href="png.h.html#L1718">png_process_data</a>(), which calls
callbacks when it has the info, a row, or the end of the image.  You
set up these callbacks with <a href="png.h.html#L1709">png_set_progressive_read_fn</a>().  You don't
have to worry about the input/output functions of libpng, as you are
giving the library the data directly in <a href="png.h.html#L1718">png_process_data</a>().  I will
assume that you have read the section on reading PNG files above,
so I will only highlight the differences (although I will show
all of the code).

png_structp png_ptr;
png_infop info_ptr;

 /*  An example code fragment of how you would
     initialize the progressive reader in your
     application. */
 int
 initialize_png_reader()
 {
    png_ptr = png_create_read_struct
        (<a href="png.h.html#L312">PNG_LIBPNG_VER_STRING</a>, (png_voidp)user_error_ptr,
         user_error_fn, user_warning_fn);

    if (!png_ptr)
        return (ERROR);

    info_ptr = png_create_info_struct(png_ptr);

    if (!info_ptr)
    {
       <a href="png.h.html#L1447">png_destroy_read_struct</a>(&amp;png_ptr,
          (png_infopp)NULL, (png_infopp)NULL);
       return (ERROR);
    }

    if (setjmp(png_jmpbuf(png_ptr)))
    {
       <a href="png.h.html#L1447">png_destroy_read_struct</a>(&amp;png_ptr, &amp;info_ptr,
          (png_infopp)NULL);
       return (ERROR);
    }

    /* This one's new.  You can provide functions
       to be called when the header info is valid,
       when each row is completed, and when the image
       is finished.  If you aren't using all functions,
       you can specify NULL parameters.  Even when all
       three functions are NULL, you need to call
       <a href="png.h.html#L1709">png_set_progressive_read_fn</a>().  You can use
       any struct as the user_ptr (cast to a void pointer
       for the function call), and retrieve the pointer
       from inside the callbacks using the function

          <a href="png.h.html#L1714">png_get_progressive_ptr</a>(png_ptr);

       which will return a void pointer, which you have
       to cast appropriately.
     */
    <a href="png.h.html#L1709">png_set_progressive_read_fn</a>(png_ptr, (void *)user_ptr,
        info_callback, row_callback, end_callback);

    return 0;
 }

 /* A code fragment that you call as you receive blocks
   of data */
 int
 process_data(png_bytep buffer, png_uint_32 length)
 {
    if (setjmp(png_jmpbuf(png_ptr)))
    {
       <a href="png.h.html#L1447">png_destroy_read_struct</a>(&amp;png_ptr, &amp;info_ptr,
           (png_infopp)NULL);
       return (ERROR);
    }

    /* This one's new also.  Simply give it a chunk
       of data from the file stream (in order, of
       course).  On machines with segmented memory
       models machines, don't give it any more than
       64K.  The library seems to run fine with sizes
       of 4K. Although you can give it much less if
       necessary (I assume you can give it chunks of
       1 byte, I haven't tried less than 256 bytes
       yet).  When this function returns, you may
       want to display any rows that were generated
       in the row callback if you don't already do
       so there.
     */
    <a href="png.h.html#L1718">png_process_data</a>(png_ptr, info_ptr, buffer, length);

    /* At this point you can call <a href="png.h.html#L1736">png_process_data_skip</a> if
       you want to handle data the library will skip yourself;
       it simply returns the number of bytes to skip (and stops
       libpng skipping that number of bytes on the next
       <a href="png.h.html#L1718">png_process_data</a> call).
    return 0;
 }

 /* This function is called (as set by
    <a href="png.h.html#L1709">png_set_progressive_read_fn</a>() above) when enough data
    has been supplied so all of the header has been
    read.
 */
 void
 info_callback(png_structp png_ptr, png_infop info)
 {
    /* Do any setup here, including setting any of
       the transformations mentioned in the Reading
       PNG files section.  For now, you _must_ call
       either <a href="png.h.html#L1395">png_start_read_image</a>() or
       <a href="png.h.html#L1398">png_read_update_info</a>() after all the
       transformations are set (even if you don't set
       any).  You may start getting rows before
       <a href="png.h.html#L1718">png_process_data</a>() returns, so this is your
       last chance to prepare for that.

       This is where you turn on interlace handling,
       assuming you don't want to do it yourself.

       If you need to you can stop the processing of
       your original input data at this point by calling
       <a href="png.h.html#L1728">png_process_data_pause</a>.  This returns the number
       of unprocessed bytes from the last <a href="png.h.html#L1718">png_process_data</a>
       call - it is up to you to ensure that the next call
       sees these bytes again.  If you don't want to bother
       with this you can get libpng to cache the unread
       bytes by setting the 'save' parameter (see png.h) but
       then libpng will have to copy the data internally.
     */
 }

 /* This function is called when each row of image
    data is complete */
 void
 row_callback(png_structp png_ptr, png_bytep new_row,
    png_uint_32 row_num, int pass)
 {
    /* If the image is interlaced, and you turned
       on the interlace handler, this function will
       be called for every row in every pass.  Some
       of these rows will not be changed from the
       previous pass.  When the row is not changed,
       the new_row variable will be NULL.  The rows
       and passes are called in order, so you don't
       really need the row_num and pass, but I'm
       supplying them because it may make your life
       easier.

       If you did not turn on interlace handling then
       the callback is called for each row of each
       sub-image when the image is interlaced.  In this
       case 'row_num' is the row in the sub-image, not
       the row in the output image as it is in all other
       cases.

       For the non-NULL rows of interlaced images when
       you have switched on libpng interlace handling,
       you must call <a href="png.h.html#L1743">png_progressive_combine_row</a>()
       passing in the row and the old row.  You can
       call this function for NULL rows (it will just
       return) and for non-interlaced images (it just
       does the memcpy for you) if it will make the
       code easier.  Thus, you can just do this for
       all cases if you switch on interlace handling;
     */

        <a href="png.h.html#L1743">png_progressive_combine_row</a>(png_ptr, old_row,
          new_row);

    /* where old_row is what was displayed
       previously for the row.  Note that the first
       pass (pass == 0, really) will completely cover
       the old row, so the rows do not have to be
       initialized.  After the first pass (and only
       for interlaced images), you will have to pass
       the current row, and the function will combine
       the old row and the new row.

       You can also call <a href="png.h.html#L1728">png_process_data_pause</a> in this
       callback - see above.
    */
 }

 void
 end_callback(png_structp png_ptr, png_infop info)
 {
    /* This function is called after the whole image
       has been read, including any chunks after the
       image (up to and including the IEND).  You
       will usually have the same info chunk as you
       had in the header, although some data may have
       been added to the comments and time fields.

       Most people won't do much here, perhaps setting
       a flag that marks the image as finished.
     */
 }



</pre>
</div>
</body>
</html>
